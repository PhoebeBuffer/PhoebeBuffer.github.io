<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos下yum本地源配置</title>
    <url>/2021/04/25/Centos%E4%B8%8Byum%E6%9C%AC%E5%9C%B0%E6%BA%90%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Centos下yum本地源配置"><a href="#Centos下yum本地源配置" class="headerlink" title="Centos下yum本地源配置"></a>Centos下yum本地源配置</h1><h2 id="1-挂载光盘（安装包）"><a href="#1-挂载光盘（安装包）" class="headerlink" title="1.挂载光盘（安装包）"></a>1.挂载光盘（安装包）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount /dev/sr0 /mnt</span><br></pre></td></tr></table></figure>

<h2 id="2-创建本地yum源配置文件"><a href="#2-创建本地yum源配置文件" class="headerlink" title="2.创建本地yum源配置文件"></a>2.创建本地yum源配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d  /etc/yum.repos.d.back</span><br><span class="line">mkdir /etc/yum.repos.d</span><br><span class="line">vim /etc/yum.repos.d/local.repo</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> loacl.repo内容如下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> name可以任意取</span></span><br><span class="line">name = localrepo </span><br><span class="line"><span class="meta">#</span><span class="bash"> 光盘路径，注意是三条斜杠</span></span><br><span class="line">baseurl = file:///mnt </span><br><span class="line">enabeld = 1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> gpgcheck=0时表示不对GPG-KEY进行检查</span></span><br><span class="line">gpgcheck = 0 </span><br></pre></td></tr></table></figure>

<h2 id="3-对yum进行初始化操作（可以略过）"><a href="#3-对yum进行初始化操作（可以略过）" class="headerlink" title="3.对yum进行初始化操作（可以略过）"></a>3.对yum进行初始化操作（可以略过）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">清除缓存</span></span><br><span class="line">yum clean all </span><br><span class="line"><span class="meta">#</span><span class="bash">建立新缓存</span></span><br><span class="line">yum makecache   </span><br></pre></td></tr></table></figure>

<h2 id="4-软件安装"><a href="#4-软件安装" class="headerlink" title="4.软件安装"></a>4.软件安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y (软件名称) </span><br></pre></td></tr></table></figure>

<h2 id="5-恢复原来的环境"><a href="#5-恢复原来的环境" class="headerlink" title="5.恢复原来的环境"></a>5.恢复原来的环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /etc/yum.repos.d</span><br><span class="line">mv /etc/yum.repos.d.back /etc/yum.repos.d</span><br><span class="line">umount /mnt</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>DSP_TMS320C66XX_DDR3配置</title>
    <url>/2021/04/26/DSP-TMS320C66XX-DDR3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="DSP-TMS320C66XX-DDR3配置"><a href="#DSP-TMS320C66XX-DDR3配置" class="headerlink" title="DSP_TMS320C66XX_DDR3配置"></a>DSP_TMS320C66XX_DDR3配置</h1><h2 id="DSP-DDR3配置一般分为五个步骤："><a href="#DSP-DDR3配置一般分为五个步骤：" class="headerlink" title="DSP DDR3配置一般分为五个步骤："></a>DSP DDR3配置一般分为五个步骤：</h2><ol>
<li>头文件部分：主要是相关操作的寄存器地址和内存操作地址的宏定义。</li>
<li>KICK的解锁和DDR3的时钟配置（PLL2）：这个操作必须要在DDR3内存控制器与DRAM的初始化之前完成。</li>
<li>LEVEING寄存器的配置：通过相应的寄存器配置完成读与写的LEVELING。</li>
<li>基本寄存器与DRAM的配置：通过相应寄存器的配置完成时间参数和模式选择参数的配置。</li>
<li>LEVELING的执行：通过相应寄存器的配置完成读与写的LEVELING的执行。</li>
</ol>
<h2 id="头文件部分"><a href="#头文件部分" class="headerlink" title="头文件部分"></a>头文件部分</h2><p>头文件部分的定义与DSP的型号有关系，分两组：the Combined Fixed Ratio Register DSPs and the Expanded Fixed Ratio Register DSPs。</p>
<table>
<thead>
<tr>
<th>Group</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Combined Fixed Ratio Register DSPs</td>
<td>TCI6602<br/>TCI6604<br/>TCI6608<br/>TCI6616<br/>TCI6618<br/>C6670<br/>C6671<br/>C6672<br/>C6674<br/>C6678</td>
</tr>
<tr>
<td>Expanded Fixed Ratio Register DSPs</td>
<td>TCI6612<br/>TCI6613<br/>TCI6614<br/>C6654<br/>C6655<br/>C6657</td>
</tr>
</tbody></table>
<p>Combined Fixed Ratio Register DSPs 头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_BASE_ADDR (0x21000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_SDCFG (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000008))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_SDRFC (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000010))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_SDTIM1 (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000018))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_SDTIM2 (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000020))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_SDTIM3 (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000028))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_PMCTL (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000038))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDWR_LVL_RMP_WIN (*(unsigned int*)(DDR3_BASE_ADDR + 0x000000D4))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDWR_LVL_RMP_CTRL (*(unsigned int*)(DDR3_BASE_ADDR + 0x000000D8))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDWR_LVL_CTRL (*(unsigned int*)(DDR3_BASE_ADDR + 0x000000DC))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_ZQCFG (*(unsigned int*)(DDR3_BASE_ADDR + 0x000000C8))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_PHYCTRL (*(unsigned int*)(DDR3_BASE_ADDR + 0x000000E4))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3PLLCTL0 (*(unsigned int*)(0x02620330))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3PLLCTL1 (*(unsigned int*)(0x02620334))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA0_WRLVL_INIT_RATIO (*(unsigned int*)(0x0262040C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA1_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620410))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA2_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620414))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA3_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620418))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA4_WRLVL_INIT_RATIO (*(unsigned int*)(0x0262041C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA5_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620420))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA6_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620424))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA7_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620428))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA8_WRLVL_INIT_RATIO (*(unsigned int*)(0x0262042C))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA0_GTLVL_INIT_RATIO (*(unsigned int*)(0x0262043C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA1_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620440))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA2_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620444))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA3_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620448))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA4_GTLVL_INIT_RATIO (*(unsigned int*)(0x0262044C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA5_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620450))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA6_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620454))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA7_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620458))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA8_GTLVL_INIT_RATIO (*(unsigned int*)(0x0262045C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_0 (*(unsigned int*)(0x02620404))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_1 (*(unsigned int*)(0x02620408))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_12 (*(unsigned int*)(0x02620434))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_23 (*(unsigned int*)(0x02620460))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_24 (*(unsigned int*)(0x02620464))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK0 (*(unsigned int*)(0x2620038))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK1 (*(unsigned int*)(0x262003C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK0_UNLOCK 0x83E70B13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK1_UNLOCK 0x95A4F1E0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK0_LOCK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK1_LOCK 0</span></span><br></pre></td></tr></table></figure>

<p>Expanded Fixed Ratio Register Sample Header 头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_BASE_ADDR (0x21000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_SDCFG (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000008))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_SDRFC (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000010))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_SDTIM1 (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000018))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_SDTIM2 (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000020))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_SDTIM3 (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000028))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_PMCTL (*(unsigned int*)(DDR3_BASE_ADDR + 0x00000038))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDWR_LVL_RMP_WIN (*(unsigned int*)(DDR3_BASE_ADDR + 0x000000D4))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDWR_LVL_RMP_CTRL (*(unsigned int*)(DDR3_BASE_ADDR + 0x000000D8))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RDWR_LVL_CTRL (*(unsigned int*)(DDR3_BASE_ADDR + 0x000000DC))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_ZQCFG (*(unsigned int*)(DDR3_BASE_ADDR + 0x000000C8))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR_PHYCTRL (*(unsigned int*)(DDR3_BASE_ADDR + 0x000000E4))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3PLLCTL0 (*(unsigned int*)(0x02620330))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3PLLCTL1 (*(unsigned int*)(0x02620334))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA0_WRLVL_INIT_RATIO (*(unsigned int*)(0x0262040C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA1_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620410))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA2_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620414))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA3_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620418))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA4_WRLVL_INIT_RATIO (*(unsigned int*)(0x0262041C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA5_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620420))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA6_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620424))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA7_WRLVL_INIT_RATIO (*(unsigned int*)(0x02620428))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA8_WRLVL_INIT_RATIO (*(unsigned int*)(0x0262042C))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA0_GTLVL_INIT_RATIO (*(unsigned int*)(0x0262043C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA1_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620440))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA2_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620444))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA3_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620448))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA4_GTLVL_INIT_RATIO (*(unsigned int*)(0x0262044C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA5_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620450))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA6_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620454))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA7_GTLVL_INIT_RATIO (*(unsigned int*)(0x02620458))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA8_GTLVL_INIT_RATIO (*(unsigned int*)(0x0262045C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_0 (*(unsigned int*)(0x02620404))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_12 (*(unsigned int*)(0x02620434))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_23 (*(unsigned int*)(0x02620460))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_24 (*(unsigned int*)(0x02620464))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_52 (*(unsigned int*)(0x026204D4))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_53 (*(unsigned int*)(0x026204D8))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_54 (*(unsigned int*)(0x026204DC))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_55 (*(unsigned int*)(0x026204E0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_56 (*(unsigned int*)(0x026204E4))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_57 (*(unsigned int*)(0x026204E8))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_58 (*(unsigned int*)(0x026204EC))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_59 (*(unsigned int*)(0x026204F0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDR3_CONFIG_REG_60 (*(unsigned int*)(0x026204F4))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK0 (*(unsigned int*)(0x2620038))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK1 (*(unsigned int*)(0x262003C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK0_UNLOCK 0x83E70B13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK1_UNLOCK 0x95A4F1E0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK0_LOCK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KICK1_LOCK 0</span></span><br></pre></td></tr></table></figure>

<h2 id="PLL配置"><a href="#PLL配置" class="headerlink" title="PLL配置"></a>PLL配置</h2><p>DDR3内存时钟速率是数据速率的一半（DDR3-1333数据操作在666.67MHz时钟下）。（PLL2_PLLD在官方例程中给的是2，但是在我们自己的板子上跑得时候给4才出了正确的图。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果图像不对降频处理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL2_PLLD 4 <span class="comment">// Must be less than 64 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL2_PLLM 39 <span class="comment">// Must be less than 4096  </span></span></span><br><span class="line"></span><br><span class="line">KICK0 = KICK0_UNLOCK;</span><br><span class="line">KICK1 = KICK1_UNLOCK;</span><br><span class="line">DDR3PLLCTL1 |= <span class="number">0x00000040</span>; <span class="comment">// Set ENSAT bit = 1</span></span><br><span class="line">DDR3PLLCTL0 |= <span class="number">0x00800000</span>; <span class="comment">// Set BYPASS bit = 1</span></span><br><span class="line"><span class="comment">// Clear and program PLLD field</span></span><br><span class="line">DDR3PLLCTL0 &amp;= ~(<span class="number">0x0000003F</span>);</span><br><span class="line">DDR3PLLCTL0 |= (PLL2_PLLD &amp; <span class="number">0x0000003F</span>);</span><br><span class="line"><span class="comment">// Clear and program PLLM field</span></span><br><span class="line">DDR3PLLCTL0 &amp;= ~(<span class="number">0x0007FFC0</span>);</span><br><span class="line">DDR3PLLCTL0 |= ((PLL2_PLLM &lt;&lt; <span class="number">6</span>) &amp; <span class="number">0x0007FFC0</span> );</span><br><span class="line"><span class="comment">// Clear and program BWADJ field</span></span><br><span class="line">temp = ((PLL2_PLLM + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">DDR3PLLCTL0 &amp;= ~(<span class="number">0xFF000000</span>);</span><br><span class="line">DDR3PLLCTL1 &amp;= ~(<span class="number">0x0000000F</span>);</span><br><span class="line">DDR3PLLCTL0 |= ((temp &lt;&lt; <span class="number">24</span>) &amp; <span class="number">0xFF000000</span>);</span><br><span class="line">DDR3PLLCTL1 |= ((temp &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x0000000F</span>);</span><br><span class="line">DDR3PLLCTL1 |= <span class="number">0x00002000</span>; <span class="comment">// Set RESET bit = 1</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++); <span class="comment">// Wait at least 5us for reset complete</span></span><br><span class="line">DDR3PLLCTL1 &amp;= ~(<span class="number">0x00002000</span>); <span class="comment">// Clear RESET bit</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">70000</span>;i++); <span class="comment">// Wait at least 50us for PLL lock</span></span><br><span class="line">DDR3PLLCTL0 &amp;= ~(<span class="number">0x00800000</span>); <span class="comment">// Clear BYPASS bit = 0</span></span><br></pre></td></tr></table></figure>

<h2 id="LEVEING寄存器的配置"><a href="#LEVEING寄存器的配置" class="headerlink" title="LEVEING寄存器的配置"></a>LEVEING寄存器的配置</h2><p>UNLOCK寄存器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">KICK0 = KICK0_UNLOCK;</span><br><span class="line">KICK1 = KICK1_UNLOCK;</span><br></pre></td></tr></table></figure>

<p>Chip-level寄存器的初始化配置leveling电路值的操作必须在基本寄存器初始化配置和DRAM初始化配置之前。这些值写入DDR3_CONFIG_REG_0和DDR3_CONFIG_REG_12中。根据leveling 过程的选择，需要往相应的leveling寄存器中写入leveling值。Combined Fixed Ratio Register DSPs需要往DDR3_CONFIG_REG_23中写值，同样的，Expanded Fixed Ratio Register DSPs需要往DDR3_CONFIG_REG_53写值。另外，当data lanes通过自动leveling时，LEVELING初始化值必须写入到WRLVL_INIT_RATIO寄存器组和GATELVL_INIT_RATIO寄存器组。</p>
<p>首先，INVERT_CLKOUT是需要配置的一个值。其配置在DDR3_CONFIG_REG_12配置寄存器中。注意：若是INVERT_CLKOUT位被设置为1，那么DDR3_CONFIG_REG_0寄存器中的CTRL_SLAVE_RATIO位必须设置为0x100；若是INVERT_CLKOUT位一直保持为0，那么CTRL_SLAVE_RATIO的值应该为0x80。而DDR3_CONFIG_REG_0中的DLL_LOCK_DIFF位应该保持为0XF。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DDR3_CONFIG_REG_0 &amp;= ~(<span class="number">0x007FE000</span>); <span class="comment">// clear ctrl_slave_ratio field</span></span><br><span class="line">DDR3_CONFIG_REG_0 |= <span class="number">0x00200000</span>; <span class="comment">// set ctrl_slave_ratio to 0x100</span></span><br><span class="line">DDR3_CONFIG_REG_12 |= <span class="number">0x08000000</span>; <span class="comment">// Set invert_clkout = 1</span></span><br><span class="line"></span><br><span class="line">DDR3_CONFIG_REG_0 |= <span class="number">0xF</span>; <span class="comment">// set dll_lock_diff to 15</span></span><br><span class="line"></span><br><span class="line">DDR3_CONFIG_REG_23 |= <span class="number">0x00000200</span>;   </span><br></pre></td></tr></table></figure>

<p>根据板子实际布线参数设置leveling初始值（根据TI给的表格DDR3 PHY Calc.xlsx来计算，表格中黄色部分表示可输入）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DATA0_WRLVL_INIT_RATIO = <span class="number">0x00</span>;</span><br><span class="line">DATA1_WRLVL_INIT_RATIO = <span class="number">0x00</span>;</span><br><span class="line">DATA2_WRLVL_INIT_RATIO = <span class="number">0x00</span>;</span><br><span class="line">DATA3_WRLVL_INIT_RATIO = <span class="number">0x00</span>;</span><br><span class="line">DATA4_WRLVL_INIT_RATIO = <span class="number">0x5C</span>;</span><br><span class="line">DATA5_WRLVL_INIT_RATIO = <span class="number">0x5C</span>;</span><br><span class="line">DATA6_WRLVL_INIT_RATIO = <span class="number">0x4D</span>;</span><br><span class="line">DATA7_WRLVL_INIT_RATIO = <span class="number">0x4D</span>;</span><br><span class="line">DATA8_WRLVL_INIT_RATIO = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">DATA0_GTLVL_INIT_RATIO = <span class="number">0x00</span>;</span><br><span class="line">DATA1_GTLVL_INIT_RATIO = <span class="number">0x00</span>;</span><br><span class="line">DATA2_GTLVL_INIT_RATIO = <span class="number">0x00</span>;</span><br><span class="line">DATA3_GTLVL_INIT_RATIO = <span class="number">0x00</span>;</span><br><span class="line">DATA4_GTLVL_INIT_RATIO = <span class="number">0x92</span>;</span><br><span class="line">DATA5_GTLVL_INIT_RATIO = <span class="number">0x92</span>;</span><br><span class="line">DATA6_GTLVL_INIT_RATIO = <span class="number">0x84</span>;</span><br><span class="line">DATA7_GTLVL_INIT_RATIO = <span class="number">0x84</span>;</span><br><span class="line">DATA8_GTLVL_INIT_RATIO = <span class="number">0x00</span>;</span><br></pre></td></tr></table></figure>

<p>将PHY_RESET设置一个脉冲（0-&gt;1-&gt;0），这样就可将leveling配置值写入到PHY逻辑中（相当于一个PHY复位操作）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DDR_PHYCTRL &amp;= ~(<span class="number">0x00008000</span>);</span><br><span class="line">DDR_PHYCTRL |= (<span class="number">0x00008000</span>);</span><br><span class="line">DDR_PHYCTRL &amp;= ~(<span class="number">0x00008000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="基本寄存器与DRAM的配置"><a href="#基本寄存器与DRAM的配置" class="headerlink" title="基本寄存器与DRAM的配置"></a>基本寄存器与DRAM的配置</h2><p>基本寄存器与DRAM的初始化配置包括DDR3控制器严格时间寄存器参数和DRAM模式寄存器参数的读写。DSP的DDR3控制器数据手册和外接DRAM的数据手册中提到的特新和这两个参数密切相关。DDR3 Register Calc表格用来选择连接不同SDRAM时的严格时间寄存器配置值。还有几个和DRAM相关的参数必须在寄存器SDCFG中配置，包括板子上连接SDRAM时电阻值以及外接SDRAM的大小参数，他们会影响DSP的DDR3内存接口和SDRAM的模式寄存器中的配置值。    </p>
<p>DDR_SDRFC寄存器控制DDR3的刷新行为。为了让DDR3很好的初始化，其刷新间隔必须为31.25us而不是正常运行时的7.8us，这样可以创造一个500us的初始化CKE low。如下表示将刷新周期31.24us写入DDR_SDRFC[15:0]（666.67*31.25）。这时DDR_SDRFC的MSB位应该清零。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DDR_SDRFC = <span class="number">0x00005161</span>;</span><br></pre></td></tr></table></figure>

<p>DDR_SDTIM包含很多和DRAM和控制器的时间配置参数，根据寄存器描述将计算好的寄存器中对应位写入其中，可以根据表格DDR3 Register Calc计算（选择DDR的型号，然后根据需要设置参数）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DDR_SDTIM1 = <span class="number">0x1113783C</span>;</span><br><span class="line">DDR_SDTIM2 = <span class="number">0x304F7FE3</span>;</span><br><span class="line">DDR_SDTIM3 = <span class="number">0x559F849F</span>;</span><br></pre></td></tr></table></figure>

<p>DDR_PHYCTRL寄存器被称为DDR_PHY_CTRL_1或者DDR_PHYC，其低5位配置读数据延迟。读延迟是基于设备延迟的，一个保守的是CL+3，这样可以使得控制器有4个时钟延迟操作周期。</p>
<p>DDR_ZQCFG寄存器配置校验电阻的调节能力，基于240欧姆的电阻连接在DRAM上，使得DRAM可以适当调整其温度漂移。每100msZQ校验会发生一次。</p>
<p>PMCTL是电源管理控制寄存器，写0表示禁止电源管理。通过电源管理控制，可以实现延时配置，类型服务配置，中断使能配置，EEC控制配置。</p>
<p>（上面三个寄存器都是从TI的6657 STK工程中的DDR初始化文件复制得来，代码如下）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DDR_PHYCTRL  = <span class="number">0x0010010F</span>;</span><br><span class="line"></span><br><span class="line">DDR_ZQCFG    = <span class="number">0x70074c1f</span>; </span><br><span class="line"></span><br><span class="line">DDR_PMCTL    = <span class="number">0x0</span>;</span><br></pre></td></tr></table></figure>

<p>DDR_ SDCFG完成控制器的配置，当DDR_SDRFC中的MSB位被清零时硬件配置DRAM设备立马执行。根据表格DDR3 Register Calc计算（选择DDR的型号，然后根据需要设置参数）特别需要注意的是，Page size 的单位是W（字），1KB = 256 字，2KB = 512字。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DDR_SDCFG   = <span class="number">0x63067BB1</span>;</span><br></pre></td></tr></table></figure>

<p>需要一个延时循环来使得以上的DDR3初始化过程能够完成，最少600us，当DDR3完成初始化后，其刷新速率应该恢复到正常状态7.8us。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++);</span><br><span class="line"></span><br><span class="line">DDR_SDRFC = <span class="number">0x00001458</span>;</span><br></pre></td></tr></table></figure>

<h2 id="LEVELING的执行"><a href="#LEVELING的执行" class="headerlink" title="LEVELING的执行"></a>LEVELING的执行</h2><p>LEVELING的执行指的是触发刚刚寄存器的读写。初始化的读写leveling的循环使得PHY中DDR byte lanes实现数据转移。有三种DDR PHY读写leveling操作方式：</p>
<ol>
<li><p>固定的leveing </p>
</li>
<li><p>局部自动leveling</p>
</li>
<li><p>全部自动leveling</p>
</li>
</ol>
<p>RDWR_LVL_CTRL和RDWR_LVL_RMP_CTRL这两个寄存器配置LEVELING的触发，（这部分也是参考的STK）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RDWR_LVL_RMP_CTRL = <span class="number">0x80000000</span>; <span class="comment">//enable full leveling</span></span><br><span class="line"></span><br><span class="line">RDWR_LVL_CTRL = <span class="number">0x80000000</span>; <span class="comment">//Trigger full leveling - This ignores read DQS leveling result and uses ratio forced value  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3000</span>;i++);</span><br></pre></td></tr></table></figure>

<h2 id="KICK寄存器"><a href="#KICK寄存器" class="headerlink" title="KICK寄存器"></a>KICK寄存器</h2><p>在执行完DDR3控制器的配置后，KICK寄存器应该锁存。其操作可以是DDR3配置后立马执行，也可以在其他内存区域完成包含之后执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">KICK0 = KICK0_LOCK; <span class="comment">//lock kicker registers</span></span><br><span class="line">KICK1 = KICK1_LOCK;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DSP</category>
      </categories>
      <tags>
        <tag>DDR3</tag>
      </tags>
  </entry>
  <entry>
    <title>优化程序性能</title>
    <url>/2021/05/12/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h1 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><h2 id="1-优化编译器的能力和局限性"><a href="#1-优化编译器的能力和局限性" class="headerlink" title="1.优化编译器的能力和局限性"></a>1.优化编译器的能力和局限性</h2><p>内存别名使用<br>函数调用</p>
<h2 id="2-表示程序性能"><a href="#2-表示程序性能" class="headerlink" title="2.表示程序性能"></a>2.表示程序性能</h2><p>CPE</p>
<h2 id="3-程序示例"><a href="#3-程序示例" class="headerlink" title="3.程序示例"></a>3.程序示例</h2><h2 id="4-消除循环的低效率"><a href="#4-消除循环的低效率" class="headerlink" title="4.消除循环的低效率"></a>4.消除循环的低效率</h2><h2 id="5-减少过程调用"><a href="#5-减少过程调用" class="headerlink" title="5.减少过程调用"></a>5.减少过程调用</h2><h2 id="6-消除不必要的内存引用"><a href="#6-消除不必要的内存引用" class="headerlink" title="6.消除不必要的内存引用"></a>6.消除不必要的内存引用</h2><h2 id="7-理解现代处理器"><a href="#7-理解现代处理器" class="headerlink" title="7.理解现代处理器"></a>7.理解现代处理器</h2><p>延迟界限<br>吞吐量界限</p>
<h3 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h3><h3 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h3><h3 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h3><h2 id="8-循环展开"><a href="#8-循环展开" class="headerlink" title="8.循环展开"></a>8.循环展开</h2><h2 id="9-提高并行性"><a href="#9-提高并行性" class="headerlink" title="9.提高并行性"></a>9.提高并行性</h2><h3 id="多个累积变量"><a href="#多个累积变量" class="headerlink" title="多个累积变量"></a>多个累积变量</h3><h3 id="重新结合变换"><a href="#重新结合变换" class="headerlink" title="重新结合变换"></a>重新结合变换</h3><h2 id="10-优化合并代码的结果小结"><a href="#10-优化合并代码的结果小结" class="headerlink" title="10.优化合并代码的结果小结"></a>10.优化合并代码的结果小结</h2><h2 id="11-一些限制因素"><a href="#11-一些限制因素" class="headerlink" title="11.一些限制因素"></a>11.一些限制因素</h2><h3 id="寄存器溢出"><a href="#寄存器溢出" class="headerlink" title="寄存器溢出"></a>寄存器溢出</h3><h3 id="分支预测和预测错误处罚"><a href="#分支预测和预测错误处罚" class="headerlink" title="分支预测和预测错误处罚"></a>分支预测和预测错误处罚</h3><h2 id="12-理解内存性能"><a href="#12-理解内存性能" class="headerlink" title="12.理解内存性能"></a>12.理解内存性能</h2><h3 id="加载的性能"><a href="#加载的性能" class="headerlink" title="加载的性能"></a>加载的性能</h3><h3 id="存储的性能"><a href="#存储的性能" class="headerlink" title="存储的性能"></a>存储的性能</h3><h2 id="13-应用：性能提高技术"><a href="#13-应用：性能提高技术" class="headerlink" title="13.应用：性能提高技术"></a>13.应用：性能提高技术</h2><h2 id="14-确认和消除性能瓶颈"><a href="#14-确认和消除性能瓶颈" class="headerlink" title="14.确认和消除性能瓶颈"></a>14.确认和消除性能瓶颈</h2><p>代码剖析程序<br>Amdahl定律</p>
<h3 id="程序剖析"><a href="#程序剖析" class="headerlink" title="程序剖析"></a>程序剖析</h3><p>UNIX的GPROF</p>
<h3 id="使用剖析程序来指导优化"><a href="#使用剖析程序来指导优化" class="headerlink" title="使用剖析程序来指导优化"></a>使用剖析程序来指导优化</h3><p>有局限性</p>
<h2 id="15-小结"><a href="#15-小结" class="headerlink" title="15.小结"></a>15.小结</h2>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>优化程序</tag>
      </tags>
  </entry>
  <entry>
    <title>信息的表示与处理</title>
    <url>/2021/04/24/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><h2 id="1-信息存储"><a href="#1-信息存储" class="headerlink" title="1.信息存储"></a>1.信息存储</h2><h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h3><ul>
<li><p>字长</p>
<p>虚拟地址空间的最大大小。<br>32位/64位<br>long，char<br>基本C 数据类型的典型大小</p>
</li>
</ul>
<h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><ul>
<li><p>多字节对象</p>
<p>多字节对象都被存储为连续的字节序<br>列，对象的地址为所使用字节中最小的地址。</p>
<ul>
<li><p>大端法</p>
<p>最高有效字节在最前面<br>例 ：x=0x01234567<br>小端法存储：01 23 45 67</p>
</li>
<li><p>小端法</p>
<p>最低有效字节在最前面<br>例 ：x=0x01234567<br>小端法存储：67 45 23 01</p>
</li>
</ul>
</li>
</ul>
<h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><p>C 语言中字符串被编码为一个以null( 其值为0) 字符结尾的字符数组</p>
<ul>
<li>ASCII 字符码</li>
</ul>
<h3 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h3><ul>
<li>程序是字节序列</li>
</ul>
<h3 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h3><ul>
<li><p>NOT，AND，OR和EXCLUSIVE-OR</p>
<p>~，&amp;，|，^</p>
</li>
<li><p>位向量运算</p>
</li>
</ul>
<h3 id="C-语言中的位级运算"><a href="#C-语言中的位级运算" class="headerlink" title="C 语言中的位级运算"></a>C 语言中的位级运算</h3><p>将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。</p>
<ul>
<li><p>掩码运算</p>
<p>x&amp;0xFF</p>
</li>
</ul>
<h3 id="C-语言中的逻辑运算"><a href="#C-语言中的逻辑运算" class="headerlink" title="C 语言中的逻辑运算"></a>C 语言中的逻辑运算</h3><ul>
<li><p>OR，AND，NOT</p>
<p>|| ，&amp;&amp;，!</p>
</li>
</ul>
<h3 id="C-语言中的移位运算"><a href="#C-语言中的移位运算" class="headerlink" title="C 语言中的移位运算"></a>C 语言中的移位运算</h3><ul>
<li>算数移位</li>
<li>逻辑移位</li>
</ul>
<h2 id="2-整数表示"><a href="#2-整数表示" class="headerlink" title="2.整数表示"></a>2.整数表示</h2><h3 id="整型数据类型"><a href="#整型数据类型" class="headerlink" title="整型数据类型"></a>整型数据类型</h3><ul>
<li><p>无符号</p>
</li>
<li><p>有符号</p>
<p>取值范围不对称</p>
</li>
</ul>
<h3 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h3><h3 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h3><p>负权重<br>负数的二进制表示<br>比如，5二进制表示为0101，<br>除去符号位即第一位0，<br>对101求反码得到010，<br>反码+1得到011即补码，<br>在首位加上符号位1，<br>则-5用二进制表示是1011。<br>这个求解过程与用公式算的结果是一样的，公式里第一位是负权重</p>
<h3 id="有符号数和无符号数之间的转换"><a href="#有符号数和无符号数之间的转换" class="headerlink" title="有符号数和无符号数之间的转换"></a>有符号数和无符号数之间的转换</h3><p>-12345=53191</p>
<h3 id="C-语言中的有符号数与无符号数"><a href="#C-语言中的有符号数与无符号数" class="headerlink" title="C 语言中的有符号数与无符号数"></a>C 语言中的有符号数与无符号数</h3><h3 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h3><ul>
<li>无符号数的零扩展</li>
<li>补码数的符号扩展</li>
</ul>
<h3 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h3><ul>
<li>截断无符号数</li>
<li>截断补码数值</li>
</ul>
<h3 id="关于有符号数与无符号数的建议"><a href="#关于有符号数与无符号数的建议" class="headerlink" title="关于有符号数与无符号数的建议"></a>关于有符号数与无符号数的建议</h3><h2 id="3-整数运算"><a href="#3-整数运算" class="headerlink" title="3.整数运算"></a>3.整数运算</h2><h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><ul>
<li>无符号数加法</li>
<li>检测无符号数加法中的溢出</li>
<li>无符号数求反</li>
</ul>
<h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><ul>
<li>补码加法</li>
<li>检测补码加法中的溢出</li>
</ul>
<h3 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h3><ul>
<li><p>补码的非</p>
<p>对每一位求补，再对结果加1</p>
</li>
</ul>
<h3 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h3><h3 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h3><ul>
<li>补码乘法</li>
<li>无符号和补码乘法的位级等价性</li>
</ul>
<h3 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h3><ul>
<li><p>乘以2的幂</p>
<p>以往，在大多数机器上，整数乘法指令相当慢， 需要10 个或者更多的时钟周期，然而其他整数运算(例如加法、减法、位级运算和移位)只需要1 个时钟周期。<br>编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。<br>（所以说编程时如果数据是2的幂会更有效率）</p>
</li>
<li><p>与2的幂相乘的无符号乘法</p>
</li>
<li><p>与2 的幂相乘的补码乘法</p>
</li>
</ul>
<h3 id="除以2-的幂"><a href="#除以2-的幂" class="headerlink" title="除以2 的幂"></a>除以2 的幂</h3><ul>
<li>除以2 的幂的无符号除法</li>
<li>除以2 的幂的补码除法，向下舍入</li>
<li>除以2 的幂的补码除法，向上舍入</li>
</ul>
<h3 id="关于整数运算的最后思考"><a href="#关于整数运算的最后思考" class="headerlink" title="关于整数运算的最后思考"></a>关于整数运算的最后思考</h3><ul>
<li>实际是模运算</li>
<li>可能溢出</li>
</ul>
<h2 id="4-浮点数"><a href="#4-浮点数" class="headerlink" title="4.浮点数"></a>4.浮点数</h2><h3 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h3><h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><ul>
<li><p>符号</p>
<p>负数(s=1) 还是正数(s=0)</p>
</li>
<li><p>尾数</p>
</li>
<li><p>阶码</p>
<p>阶码的值决定了这个数是规格化的、非规格化的或特殊值</p>
<ul>
<li><p>规格化的值</p>
<p>当exp 的位模式既不全为0( 数值0) ，也不全为1 (单精度数值为255 ，双精度数值为2047) 时</p>
<p>e-bias</p>
<p>M = 1+f</p>
</li>
<li><p>非规格化的值</p>
<p>阶码域为全0</p>
<p>1-bias</p>
<p>M = f</p>
</li>
<li><p>特殊值</p>
<p>当阶码全为1</p>
</li>
</ul>
</li>
</ul>
<h3 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h3><ul>
<li>单精度与双精度</li>
<li>整数值转换为浮点形式</li>
</ul>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><ul>
<li><p>向最接近的值舍入</p>
<p>也称向偶数舍入<br>它将数字向上或者向下舍入，使得结果的<br>最低有效数字是偶数。</p>
</li>
<li><p>向零舍入</p>
</li>
<li><p>向下舍入</p>
</li>
<li><p>向上舍入</p>
</li>
</ul>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><h3 id="C语言中的浮点数"><a href="#C语言中的浮点数" class="headerlink" title="C语言中的浮点数"></a>C语言中的浮点数</h3><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>信息表示</tag>
      </tags>
  </entry>
  <entry>
    <title>函数回调</title>
    <url>/2021/04/29/%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83/</url>
    <content><![CDATA[<p>来源：<a href="https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/7545973?fr=aladdin">百度百科</a></p>
<h1 id="函数回调"><a href="#函数回调" class="headerlink" title="函数回调"></a>函数回调</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数就是一个通过<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/2674905">函数指针</a>调用的函数。如果你把函数的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304">指针</a>（地址）作为<a href="https://baike.baidu.com/item/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/9019335">参数传递</a>给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。==回调函数不是由该函数的实现方直接调用==，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p>回调是任何一个被以方法为其第一个参数的其它方法的调用的方法。很多时候，回调是一个当某些事件发生时被调用的方法。</p>
<h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>⑴定义一个回调函数；</p>
<p>⑵提供函数实现的一方在初始化的时候，将回调函数的函数指针==注册==给调用者；</p>
<p>⑶当特定的事件或条件发生的时候，调用者==使用函数指针调用回调函数==对事件进行处理。</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>因为可以把调用者与被调用者分开，所以调用者不关心谁是被调用者。它只需知道存在一个具有特定原型和限制条件的<a href="https://baike.baidu.com/item/%E8%A2%AB%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">被调用函数</a>。简而言之，回调函数就是允许用户把需要调用的函数的指针作为参数传递给一个函数，以便该函数在处理相似事件的时候可以灵活的使用不同的方法。</p>
<p>想知道回调函数在实际中有什么作用？先假设有这样一种情况：我们要编写一个库，它提供了某些<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a>的实现（如<a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a>、<a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>、<a href="https://baike.baidu.com/item/shell%E6%8E%92%E5%BA%8F">shell排序</a>、shake排序等等），为了能让库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，能让库可用于多种数据类型（int、float、string），此时，该怎么办呢？可以使用函数指针，并进行回调。</p>
<p>回调可用于通知机制。例如，有时要在A程序中设置一个计时器，每到一定时间，A程序会得到相应的通知，但通知机制的实现者对A程序一无所知。那么，就需一个具有特定原型的函数指针进行回调，通知A程序事件已经发生。实际上，<a href="https://baike.baidu.com/item/API">API</a>使用一个回调函数SetTimer()来通知计时器。如果没有提供回调函数，它还会把一个消息发往程序的<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a>。</p>
<p>另一个使用回调机制的API函数是EnumWindow（），它<a href="https://baike.baidu.com/item/%E6%9E%9A%E4%B8%BE">枚举</a>屏幕上所有的顶层窗口，每个窗口都可以通过它调用另一个程序提供的函数，并传递窗口的处理程序。例如：如果被调用者返回一个值，就继续进行<a href="https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3">迭代</a>；否则，退出。EnumWindow()并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。</p>
<p>不管怎么说，回调函数是继承自C语言的。在C++中，应只在与C代码建立接口或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在C++中应使用虚拟方法或<a href="https://baike.baidu.com/item/%E4%BB%BF%E5%87%BD%E6%95%B0">仿函数</a>（functor），而不是回调函数。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面创建了一个sort.dll的动态链接库，它导出了一个名为CompareFunction的类型–</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(__stdcall*CompareFunction)</span><span class="params">(constbyte*,constbyte*）</span></span></span><br></pre></td></tr></table></figure>

<p>它就是回调函数的类型，负责用同样的参数形式将参数传递给相应的具体元素比较函数。另外，通过它，两个不同的排序算法，可以调用和具体元素相关的比较函数，实现和元素类型无关的排序：Bubblesort（）和Quicksort（），这两个方法都用同样的参数原型，但实现了不同的排序算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DLLDIR__stdcallBubblesort</span><span class="params">(byte* <span class="built_in">array</span>,<span class="keyword">int</span> size,<span class="keyword">int</span> elem_size,CompareFunction cmpFunc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DLLDIR__stdcallQuicksort</span><span class="params">(byte* <span class="built_in">array</span>,<span class="keyword">int</span> size,<span class="keyword">int</span> elem_size,CompareFunction cmpFunc)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数接受以下参数：</p>
<p>·byte * array：指向元素数组的指针（任意类型）。</p>
<p>·int size：数组中元素的个数。</p>
<p>·int elem_size：数组中一个元素的大小，以字节为单位。</p>
<p>·CompareFunction cmpFunc：带有上述原型的指向回调函数的指针。</p>
<p>这两个函数都会对数组进行某种排序，但每次都需决定两个元素哪个排在前面，而函数中有一个回调函数，其地址是作为一个参数传递进来的。对编写者来说，不必介意函数在何处实现，或它怎样被实现的，所需在意的只是两个用于比较的元素的地址，并返回以下的某个值（库的编写者和使用者都必须遵守这个约定）：</p>
<p>-1：如果第一个元素较小，那它在已排序好的数组中，应该排在第二个元素前面。</p>
<p>·0：如果两个元素相等，那么它们的相对位置并不重要，在已排序好的数组中，谁在前面都无所谓。</p>
<p>·1：如果第一个元素较大，那在已排序好的数组中，它应该排第二个元素后面。</p>
<p>基于以上约定，函数Bubblesort（）的实现如下，Quicksort（）就稍微复杂一点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> DLLDIR__stdcall <span class="title">Bubblesort</span><span class="params">(byte*<span class="built_in">array</span>,intsize,intelem_size,cmpFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(inti=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(intj=<span class="number">0</span>;j&lt;size-i<span class="number">-1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//回调比较函数</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>==(*cmpFunc)(<span class="built_in">array</span>+j*elem_size,<span class="built_in">array</span>+(j+<span class="number">1</span>)*elem_size))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//两个相比较的元素相交换</span></span><br><span class="line">byte* temp=newbyte[elem_size];</span><br><span class="line"><span class="built_in">memcpy</span>(temp,<span class="built_in">array</span>+j*elem_size,elem_size);</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="built_in">array</span>+j*elem_size,<span class="built_in">array</span>+(j+<span class="number">1</span>)*elem_size,elem_size);</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="built_in">array</span>+(j+<span class="number">1</span>)*elem_size,temp,elem_size);</span><br><span class="line"><span class="keyword">delete</span>[]temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：因为实现中使用了memcpy（），所以函数在使用的数据类型方面，会有所局限。</p>
<p>对使用者来说，必须有一个回调函数，其地址要传递给Bubblesort（）函数。下面有二个简单的示例，一个比较两个整数，而另一个比较两个字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">int__stdcall <span class="title">CompareInts</span><span class="params">(constbyte*velem1,constbyte*velem2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> elem1=*(<span class="keyword">int</span>*)velem1;</span><br><span class="line"><span class="keyword">int</span> elem2=*(<span class="keyword">int</span>*)velem2;</span><br><span class="line"><span class="keyword">if</span>(elem1&lt;elem2)</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(elem1&gt;elem2)</span><br><span class="line">return1;</span><br><span class="line">return0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">CompareStrings</span><span class="params">(constbyte*velem1,constbyte*velem2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* elem1=(<span class="keyword">char</span>*)velem1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* elem2=(<span class="keyword">char</span>*)velem2;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(elem1,elem2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面另有一个程序，用于测试以上所有的代码，它传递了一个有5个元素的<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84">数组</a>给Bubblesort（）和Quicksort（），同时还传递了一个指向回调函数的指针。（使用byte类型需包含头文件windows.h，或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> unsignedchar byte;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(intargc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">5432</span>,<span class="number">4321</span>,<span class="number">3210</span>,<span class="number">2109</span>,<span class="number">1098</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Before sorting ints with Bubblesort\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">array</span>[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">Bubblesort((byte*)<span class="built_in">array</span>,<span class="number">5</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]),&amp;CompareInts);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;After the sorting\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">array</span>[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[<span class="number">5</span>][<span class="number">10</span>]=&#123;<span class="string">&quot;estella&quot;</span>,<span class="string">&quot;danielle&quot;</span>,<span class="string">&quot;crissy&quot;</span>,<span class="string">&quot;bo&quot;</span>,<span class="string">&quot;angie&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Before sorting strings with Quicksort\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">Quicksort((byte*)str,<span class="number">5</span>,<span class="number">10</span>,&amp;CompareStrings);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;After the sorting\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想进行降序排序（大元素在先），就只需修改回调函数的代码，或使用另一个回调函数，这样编程起来灵活性就比较大了。</p>
<h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>上面的代码中，可在函数原型中找到__stdcall，因为它以双下划线打头，所以它是一个特定于编译器的扩展，说到底也就是微软的实现。任何支持开发基于Win32的程序都必须支持这个扩展或其等价物。以__stdcall标识的函数使用了标准调用约定，为什么叫标准约定呢，因为所有的Win32 API（除了个别接受可变参数的除外）都使用它。标准调用约定的函数在它们返回到调用者之前，都会从堆栈中移除掉参数，这也是Pascal的标准约定。但在C/C++中，调用约定是调用者负责清理堆栈，而不是被调用函数；为强制函数使用C/C++调用约定，可使用__cdecl。另外，可变参数函数也使用C/C++调用约定。</p>
<p>Windows操作系统采用了标准调用约定（Pascal约定），因为其可减小代码的体积。这点对早期的Windows来说非常重要，因为那时它运行在只有640KB内存的电脑上。</p>
<p>如果你不喜欢__stdcall，还可以使用CALLBACK宏，它定义在windef.h中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALLBACK__stdcallor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALLBACKPASCAL<span class="comment">//而PASCAL在此被#defined成__stdcall</span></span></span><br></pre></td></tr></table></figure>

<p>作为回调函数的C++方法</p>
<p>因为平时很可能会使用到C++编写代码，也许会想到把回调函数写成类中的一个方法，但先来看看以下的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCallbackTester</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CALLBACKCompareInts</span><span class="params">(constbyte*velem1,constbyte*velem2)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Bubblesort((byte*)<span class="built_in">array</span>,<span class="number">5</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]),&amp;CCallbackTester::CompareInts);</span><br></pre></td></tr></table></figure>

<p>如果使用微软的编译器，将会得到下面这个编译错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">errorC2664:’Bubblesort’:cannotconvertparameter4from’int(__stdcallCCallbackTester::*)(constunsignedchar*,constunsignedchar*）’to’int(__stdcall*)(constunsignedchar*,constunsignedchar*）’There is no context in which this conversion is possible</span><br></pre></td></tr></table></figure>

<p>这是因为非静态成员函数有一个额外的参数：this指针，这将迫使你在成员函数前面加上static。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>函数回调</tag>
      </tags>
  </entry>
  <entry>
    <title>处理器体系结构</title>
    <url>/2021/04/28/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="处理器体系结构"><a href="#处理器体系结构" class="headerlink" title="处理器体系结构"></a>处理器体系结构</h1><h2 id="1-Y86-64指令集体系结构"><a href="#1-Y86-64指令集体系结构" class="headerlink" title="1.Y86-64指令集体系结构"></a>1.Y86-64指令集体系结构</h2><p>定义一个指令集体系结构(例如Y86-64 )包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。</p>
<h3 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h3><p>这里的”程序员”既可以是用汇编代码写程序的人，也可以是产生<br>机器级代码的编译器</p>
<h3 id="Y86-64指令"><a href="#Y86-64指令" class="headerlink" title="Y86-64指令"></a>Y86-64指令</h3><h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><h3 id="Y86-64异常"><a href="#Y86-64异常" class="headerlink" title="Y86-64异常"></a>Y86-64异常</h3><h3 id="Y86-64程序"><a href="#Y86-64程序" class="headerlink" title="Y86-64程序"></a>Y86-64程序</h3><h3 id="一些Y86-64指令的详情"><a href="#一些Y86-64指令的详情" class="headerlink" title="一些Y86-64指令的详情"></a>一些Y86-64指令的详情</h3><h2 id="2-逻辑设计和硬件控制语言HCL"><a href="#2-逻辑设计和硬件控制语言HCL" class="headerlink" title="2.逻辑设计和硬件控制语言HCL"></a>2.逻辑设计和硬件控制语言HCL</h2><h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h3><h3 id="组合电路和HCL布尔表达式"><a href="#组合电路和HCL布尔表达式" class="headerlink" title="组合电路和HCL布尔表达式"></a>组合电路和HCL布尔表达式</h3><h3 id="字级的组合电路和HCL整数表达式"><a href="#字级的组合电路和HCL整数表达式" class="headerlink" title="字级的组合电路和HCL整数表达式"></a>字级的组合电路和HCL整数表达式</h3><h3 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h3><h3 id="存储器和时钟"><a href="#存储器和时钟" class="headerlink" title="存储器和时钟"></a>存储器和时钟</h3><p>时钟寄存器、随机访问存储器<br>硬件寄存器、程序寄存器</p>
<h2 id="3-Y86-64的顺序实现（没懂）"><a href="#3-Y86-64的顺序实现（没懂）" class="headerlink" title="3.Y86-64的顺序实现（没懂）"></a>3.Y86-64的顺序实现（没懂）</h2><h3 id="将处理组织成阶段"><a href="#将处理组织成阶段" class="headerlink" title="将处理组织成阶段"></a>将处理组织成阶段</h3><p>取指<br>译码<br>执行<br>访存<br>写回<br>更新</p>
<h3 id="SEQ硬件结构"><a href="#SEQ硬件结构" class="headerlink" title="SEQ硬件结构"></a>SEQ硬件结构</h3><h2 id="4-流水线的通用原理"><a href="#4-流水线的通用原理" class="headerlink" title="4.流水线的通用原理"></a>4.流水线的通用原理</h2><p>吞吐量（单位时间的顾客总数，顾客就是指令）<br>延迟（服务一个用户所需要的时间）</p>
<h3 id="计算流水线"><a href="#计算流水线" class="headerlink" title="计算流水线"></a>计算流水线</h3><h3 id="流水线操作的详细说明"><a href="#流水线操作的详细说明" class="headerlink" title="流水线操作的详细说明"></a>流水线操作的详细说明</h3><h3 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h3><p>不一样的阶段延迟<br>流水线过深，收益反而下降</p>
<h3 id="带反馈的流水线系统"><a href="#带反馈的流水线系统" class="headerlink" title="带反馈的流水线系统"></a>带反馈的流水线系统</h3><h2 id="5-Y86-64的流水线实现（必须重看）"><a href="#5-Y86-64的流水线实现（必须重看）" class="headerlink" title="5.Y86-64的流水线实现（必须重看）"></a>5.Y86-64的流水线实现（必须重看）</h2><p>首先，对顺序的SEQ 处理器做一点小的改动，将PC 的计算挪到取指阶段。然后，在各个阶段之间加上流水线寄存器</p>
<h3 id="重新安排计算阶段"><a href="#重新安排计算阶段" class="headerlink" title="重新安排计算阶段"></a>重新安排计算阶段</h3><p>SEQ+<br>电路重定时</p>
<h3 id="插入流水线寄存器"><a href="#插入流水线寄存器" class="headerlink" title="插入流水线寄存器"></a>插入流水线寄存器</h3><p>PIPE-处理器（这里的”- “代表这个处理器和最终的处理器设计相比，性能要差一点。）</p>
<h3 id="对信号进行重新排列和标号"><a href="#对信号进行重新排列和标号" class="headerlink" title="对信号进行重新排列和标号"></a>对信号进行重新排列和标号</h3><h3 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h3><h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><p>气泡<br>转发<br>加载/使用数据冒险<br>避免控制冒险</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>内部异常<br>外部异常</p>
<h3 id="PIPE各阶段的实现"><a href="#PIPE各阶段的实现" class="headerlink" title="PIPE各阶段的实现"></a>PIPE各阶段的实现</h3><h3 id="流水线控制逻辑"><a href="#流水线控制逻辑" class="headerlink" title="流水线控制逻辑"></a>流水线控制逻辑</h3><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>CPI</p>
<h3 id="未完成的工作"><a href="#未完成的工作" class="headerlink" title="未完成的工作"></a>未完成的工作</h3><p>多周期指令</p>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>处理器</tag>
      </tags>
  </entry>
  <entry>
    <title>存储器层次结构</title>
    <url>/2021/05/12/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><h2 id="1-存储技术"><a href="#1-存储技术" class="headerlink" title="1.存储技术"></a>1.存储技术</h2><h3 id="随机访问存储器（RAM）"><a href="#随机访问存储器（RAM）" class="headerlink" title="随机访问存储器（RAM）"></a>随机访问存储器（RAM）</h3><ul>
<li><p>静态（SRAM）</p>
<p>双稳态<br>钟摆</p>
</li>
<li><p>动态（DRAM）</p>
</li>
<li><p>传统的DRAM</p>
</li>
<li><p>内存模块</p>
</li>
<li><p>增强的DRAM</p>
</li>
<li><p>非易失性存储器</p>
</li>
<li><p>访问主存</p>
</li>
</ul>
<h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h3><ul>
<li><p>磁盘构造</p>
</li>
<li><p>磁盘容量</p>
</li>
<li><p>磁盘操作</p>
</li>
<li><p>逻辑磁盘块</p>
</li>
<li><p>连接IO设备</p>
</li>
<li><p>访问磁盘</p>
<p>内存映射<br>直接内存访问（DMA）</p>
</li>
</ul>
<h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><h3 id="存储技术趋势"><a href="#存储技术趋势" class="headerlink" title="存储技术趋势"></a>存储技术趋势</h3><h2 id="2-局部性"><a href="#2-局部性" class="headerlink" title="2.局部性"></a>2.局部性</h2><p>一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理(principle of locality )</p>
<h3 id="对程序数据引用的局部性"><a href="#对程序数据引用的局部性" class="headerlink" title="对程序数据引用的局部性"></a>对程序数据引用的局部性</h3><h3 id="取指令的局部性"><a href="#取指令的局部性" class="headerlink" title="取指令的局部性"></a>取指令的局部性</h3><h2 id="3-存储器层次结构"><a href="#3-存储器层次结构" class="headerlink" title="3.存储器层次结构"></a>3.存储器层次结构</h2><h3 id="缓存（cache）"><a href="#缓存（cache）" class="headerlink" title="缓存（cache）"></a>缓存（cache）</h3><p>低层次作为高层次的缓存</p>
<ul>
<li>缓存命中</li>
<li>缓存不命中</li>
<li>缓存不命中的种类</li>
<li>缓存管理</li>
</ul>
<h2 id="4-高速缓存存储器"><a href="#4-高速缓存存储器" class="headerlink" title="4.高速缓存存储器"></a>4.高速缓存存储器</h2><h3 id="通用的高速缓存存储器组织结构"><a href="#通用的高速缓存存储器组织结构" class="headerlink" title="通用的高速缓存存储器组织结构"></a>通用的高速缓存存储器组织结构</h3><h3 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h3><p>E = 1<br>每个组只有一行</p>
<ul>
<li><p>组选择</p>
</li>
<li><p>行匹配</p>
</li>
<li><p>字抽取</p>
</li>
<li><p>直接映射高速缓存中不命中时的行替换</p>
<p>新行替代当前行</p>
</li>
<li><p>综合:：运行中的直接映射高速缓存</p>
</li>
<li><p>直接映射高速缓存中的冲突不命中</p>
<p>抖动</p>
</li>
</ul>
<h3 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h3><p>1&lt; E &lt; C/B</p>
<ul>
<li>组选择</li>
<li>行匹配和字选择</li>
<li>行替换</li>
</ul>
<h3 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h3><p>E = C/B<br>只有一个组<br>没有组索引</p>
<ul>
<li>组选择</li>
<li>行匹配和字选择</li>
</ul>
<h3 id="有关写的问题"><a href="#有关写的问题" class="headerlink" title="有关写的问题"></a>有关写的问题</h3><ul>
<li>写命中</li>
<li>写不命中</li>
</ul>
<h3 id="一个真实的高速缓存层次结构的解剖"><a href="#一个真实的高速缓存层次结构的解剖" class="headerlink" title="一个真实的高速缓存层次结构的解剖"></a>一个真实的高速缓存层次结构的解剖</h3><h3 id="高速缓存参数的性能影晌"><a href="#高速缓存参数的性能影晌" class="headerlink" title="高速缓存参数的性能影晌"></a>高速缓存参数的性能影晌</h3><h2 id="5-编写高速缓存友好的代码"><a href="#5-编写高速缓存友好的代码" class="headerlink" title="5.编写高速缓存友好的代码"></a>5.编写高速缓存友好的代码</h2><h3 id="让最常见的情况运行得快"><a href="#让最常见的情况运行得快" class="headerlink" title="让最常见的情况运行得快"></a>让最常见的情况运行得快</h3><h3 id="尽量减小每个循环内部的缓存不命中数量"><a href="#尽量减小每个循环内部的缓存不命中数量" class="headerlink" title="尽量减小每个循环内部的缓存不命中数量"></a>尽量减小每个循环内部的缓存不命中数量</h3><h2 id="6-综合：高速缓存对程序性能的影响"><a href="#6-综合：高速缓存对程序性能的影响" class="headerlink" title="6.综合：高速缓存对程序性能的影响"></a>6.综合：高速缓存对程序性能的影响</h2><h3 id="存储器山（？？）"><a href="#存储器山（？？）" class="headerlink" title="存储器山（？？）"></a>存储器山（？？）</h3><h3 id="重新排列循环以提高空间局部性"><a href="#重新排列循环以提高空间局部性" class="headerlink" title="重新排列循环以提高空间局部性"></a>重新排列循环以提高空间局部性</h3><h3 id="在程序中利用局部性"><a href="#在程序中利用局部性" class="headerlink" title="在程序中利用局部性"></a>在程序中利用局部性</h3><p>将你的注意力集中在内循环上，大部分计算和内存访问都发生在这里。<br>通过按照数据对象存储在内存中的顺序、以步长为1 的来读数据，从而使得你程序中的空间局部性最大。<br>一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大。</p>
<h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h2>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>存储器</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/2021/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>如果逻辑控制流在时间上重叠，那么它们就是并发的<br>( concurrent) 。这种常见的现象称为并发(concurrency)<br>进程<br>I/O多路复用<br>线程</p>
<h2 id="1-基于进程的并发编程"><a href="#1-基于进程的并发编程" class="headerlink" title="1.基于进程的并发编程"></a>1.基于进程的并发编程</h2><h3 id="基于进程的并发服务器"><a href="#基于进程的并发服务器" class="headerlink" title="基于进程的并发服务器"></a>基于进程的并发服务器</h3><h3 id="进程的优劣"><a href="#进程的优劣" class="headerlink" title="进程的优劣"></a>进程的优劣</h3><p>对于在父、子进程间共享状态信息，进程有一个非常清晰的模型:共享文件表，但是不共享用户地址空间</p>
<h2 id="2-基于I-O-多路复用的并发编程"><a href="#2-基于I-O-多路复用的并发编程" class="headerlink" title="2.基于I/O 多路复用的并发编程"></a>2.基于I/O 多路复用的并发编程</h2><h3 id="基于I-O多路复用的并发事件驱动服务器"><a href="#基于I-O多路复用的并发事件驱动服务器" class="headerlink" title="基于I/O多路复用的并发事件驱动服务器"></a>基于I/O多路复用的并发事件驱动服务器</h3><h3 id="I-O多路复用技术的优劣"><a href="#I-O多路复用技术的优劣" class="headerlink" title="I/O多路复用技术的优劣"></a>I/O多路复用技术的优劣</h3><h2 id="3-基于线程的并发编程"><a href="#3-基于线程的并发编程" class="headerlink" title="3.基于线程的并发编程"></a>3.基于线程的并发编程</h2><p>线程( thread) 就是运行在进程上下文中的逻辑流</p>
<h3 id="线程执行模型"><a href="#线程执行模型" class="headerlink" title="线程执行模型"></a>线程执行模型</h3><h3 id="Posix-线程"><a href="#Posix-线程" class="headerlink" title="Posix 线程"></a>Posix 线程</h3><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程通过调用pthread_create 函数来创建其他线程。<br>当pthread_create 返回时，参数tid 包含新创建线程的ID 。新线程可以通过调用pthread_self 函数来获得它自己的线程ID 。</p>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><h3 id="回收已终止线程的资源"><a href="#回收已终止线程的资源" class="headerlink" title="回收已终止线程的资源"></a>回收已终止线程的资源</h3><p>线程通过调用pthread_join 函数等待其他线程终止。</p>
<h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>可结合的<br>可分离的</p>
<h3 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h3><p>pthread_once 函数允许你初始化与线程例程相关的状态。</p>
<h3 id="基于线程的并发服务器"><a href="#基于线程的并发服务器" class="headerlink" title="基于线程的并发服务器"></a>基于线程的并发服务器</h3><h2 id="4-多线程程序中的共享变量"><a href="#4-多线程程序中的共享变量" class="headerlink" title="4.多线程程序中的共享变量"></a>4.多线程程序中的共享变量</h2><h3 id="线程内存模型"><a href="#线程内存模型" class="headerlink" title="线程内存模型"></a>线程内存模型</h3><h3 id="将变量映射到内存"><a href="#将变量映射到内存" class="headerlink" title="将变量映射到内存"></a>将变量映射到内存</h3><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><h2 id="5-用信号量同步线程"><a href="#5-用信号量同步线程" class="headerlink" title="5.用信号量同步线程"></a>5.用信号量同步线程</h2><h3 id="进度图"><a href="#进度图" class="headerlink" title="进度图"></a>进度图</h3><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>P<br>V</p>
<h3 id="使用信号量来实现互斥"><a href="#使用信号量来实现互斥" class="headerlink" title="使用信号量来实现互斥"></a>使用信号量来实现互斥</h3><h3 id="利用信号量来调度共享资源"><a href="#利用信号量来调度共享资源" class="headerlink" title="利用信号量来调度共享资源"></a>利用信号量来调度共享资源</h3><p>经典而有用的例子是生产者-消费者和读者-写者问题。</p>
<h3 id="综合-：基于预线程化的并发服务器"><a href="#综合-：基于预线程化的并发服务器" class="headerlink" title="综合:：基于预线程化的并发服务器"></a>综合:：基于预线程化的并发服务器</h3><h2 id="6-使用线程提高并行性"><a href="#6-使用线程提高并行性" class="headerlink" title="6.使用线程提高并行性"></a>6.使用线程提高并行性</h2><h2 id="7-其他并发问题"><a href="#7-其他并发问题" class="headerlink" title="7.其他并发问题"></a>7.其他并发问题</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><h3 id="在线程化的程序中使用已存在的库函数"><a href="#在线程化的程序中使用已存在的库函数" class="headerlink" title="在线程化的程序中使用已存在的库函数"></a>在线程化的程序中使用已存在的库函数</h3><h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>当一个程序的正确性依赖于一个线程要在另一个线程到达y 点之前到达它的控制流中的x点时，就会发生竞争(race) 。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>信号量引入了一种潜在的令人厌恶的运行时错误，叫做死锁(deadlock) ，它指的是一组线程被阻塞了，等待一个永远也不会为真的条件<br>如何避免死锁：<br>互斥锁加锁顺序规则：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的</p>
<h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h2>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>系统级IO</title>
    <url>/2021/05/12/%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
    <content><![CDATA[<h1 id="系统级IO"><a href="#系统级IO" class="headerlink" title="系统级IO"></a>系统级IO</h1><p>输入/ 输出（I/O）是在主存和外部设备(例如磁盘驱动器、终端和网络)之间复制数据的过程。<br>输入操作是从I/O设备复制数据到主存，而输出操作是从主存复制数据到I/O设备。</p>
<h2 id="1-Unix-I-O"><a href="#1-Unix-I-O" class="headerlink" title="1.Unix I/O"></a>1.Unix I/O</h2><p>所有的I/O设备都被模型化为文件。<br>打开文件（描述符）<br>标准输入、标准输出、标准错误<br>改变当前的文件位置（文件位置k）<br>读写文件<br>关闭文件</p>
<h2 id="2-文件"><a href="#2-文件" class="headerlink" title="2.文件"></a>2.文件</h2><h3 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h3><p>文本文件<br>二进制文件</p>
<h3 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h3><p>是包含一组链接( link) 的文件</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>用来与另一个进程进行跨网络通信的文件</p>
<h3 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h3><h3 id="绝对-相对路径名"><a href="#绝对-相对路径名" class="headerlink" title="绝对/相对路径名"></a>绝对/相对路径名</h3><h2 id="3-打开和关闭文件"><a href="#3-打开和关闭文件" class="headerlink" title="3.打开和关闭文件"></a>3.打开和关闭文件</h2><h3 id="open（）"><a href="#open（）" class="headerlink" title="open（）"></a>open（）</h3><h3 id="close（）"><a href="#close（）" class="headerlink" title="close（）"></a>close（）</h3><h2 id="4-读和写文件"><a href="#4-读和写文件" class="headerlink" title="4.读和写文件"></a>4.读和写文件</h2><p>在某些情况下， read 和write 传送的字节比应用程序要求的要少。这些不足值（short count) 不表示有错误：<br>读时遇到EOF；<br>从终端读文本行；<br>读和写网络套接字</p>
<h3 id="read（）"><a href="#read（）" class="headerlink" title="read（）"></a>read（）</h3><h3 id="write（）"><a href="#write（）" class="headerlink" title="write（）"></a>write（）</h3><h2 id="5-用RIO-包健壮地读写"><a href="#5-用RIO-包健壮地读写" class="headerlink" title="5.用RIO 包健壮地读写"></a>5.用RIO 包健壮地读写</h2><p>RIO，Robust I/ O ，健壮的I/O包<br>会自动为你处理第4节中所述的不足值</p>
<h3 id="RIO-的无缓冲的输入输出函数"><a href="#RIO-的无缓冲的输入输出函数" class="headerlink" title="RIO 的无缓冲的输入输出函数"></a>RIO 的无缓冲的输入输出函数</h3><p>函数直接在内存和文件之间传送数据<br>rio_read口和rio_writen</p>
<h3 id="RIO-的带缓冲的输入函数"><a href="#RIO-的带缓冲的输入函数" class="headerlink" title="RIO 的带缓冲的输入函数"></a>RIO 的带缓冲的输入函数</h3><p>包装函数rio_readlineb它从一个内部读缓冲区复制一个文本行，当缓冲区变空时，会自动地调用read 重新填满缓冲区</p>
<p>对于既包含文本行也包含二进制数据的文件,我们也提供了一个rio readn 带缓冲区的版本，叫做rio_readn，它从和rio_readlineb 一样的读缓冲区中传送原始字节。</p>
<h2 id="6-读取文件元数据"><a href="#6-读取文件元数据" class="headerlink" title="6.读取文件元数据"></a>6.读取文件元数据</h2><p>应用程序能够通过调用stat 和fstat 函数，检索到关于文件的信息(有时也称为文件的元数据(metadata) )。</p>
<h2 id="7-读取目录内容"><a href="#7-读取目录内容" class="headerlink" title="7.读取目录内容"></a>7.读取目录内容</h2><p>d_ino<br>d_name</p>
<h3 id="opendir（）"><a href="#opendir（）" class="headerlink" title="opendir（）"></a>opendir（）</h3><h3 id="readdir（）"><a href="#readdir（）" class="headerlink" title="readdir（）"></a>readdir（）</h3><h3 id="closedir（）"><a href="#closedir（）" class="headerlink" title="closedir（）"></a>closedir（）</h3><h2 id="8-共享文件"><a href="#8-共享文件" class="headerlink" title="8.共享文件"></a>8.共享文件</h2><p>内核用三个相关的数据结构来表示打开的文件</p>
<p>每个描述符有自己的文件位置</p>
<h3 id="描述符表"><a href="#描述符表" class="headerlink" title="描述符表"></a>描述符表</h3><h3 id="文件表"><a href="#文件表" class="headerlink" title="文件表"></a>文件表</h3><h3 id="v-node表"><a href="#v-node表" class="headerlink" title="v-node表"></a>v-node表</h3><h2 id="9-I-O重定向"><a href="#9-I-O重定向" class="headerlink" title="9.I/O重定向"></a>9.I/O重定向</h2><h3 id="dup2（）"><a href="#dup2（）" class="headerlink" title="dup2（）"></a>dup2（）</h3><p>dup2 函数复制描述符表表项oldfd 到描述符表表项newfd ，覆盖描述符表表项newfd以前的内容。<br>如果newfd 已经打开了， dup2 会在复制oldfd 之前关闭newfd 。</p>
<h2 id="10-标准I-O"><a href="#10-标准I-O" class="headerlink" title="10.标准I/O"></a>10.标准I/O</h2><h3 id="fopen和fclose"><a href="#fopen和fclose" class="headerlink" title="fopen和fclose"></a>fopen和fclose</h3><h3 id="fread和fwrite"><a href="#fread和fwrite" class="headerlink" title="fread和fwrite"></a>fread和fwrite</h3><h3 id="fgets和fputs"><a href="#fgets和fputs" class="headerlink" title="fgets和fputs"></a>fgets和fputs</h3><h3 id="scanf和printf"><a href="#scanf和printf" class="headerlink" title="scanf和printf"></a>scanf和printf</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h2 id="11-综合-我该使用哪些I-O函数"><a href="#11-综合-我该使用哪些I-O函数" class="headerlink" title="11.综合:我该使用哪些I/O函数?"></a>11.综合:我该使用哪些I/O函数?</h2><p>1.只要有可能就使用标准I/O<br>2.不要使用scanf 或rio_readlineb 来读二进制文件<br>3.对网络套接字的I/O 使用RIO 函数<br>（在网络套接字上，如果你需要格式化的输出，使用sprintf 函数在内存中格式化一个字符串，然后用rio_writen 把它发送到套接口。如果你需要格式化输入，使用rio_readlineb 来读一个完整的文本行，然后用sscanf 从文本行提取不同的字段。）</p>
<h2 id="12-小结"><a href="#12-小结" class="headerlink" title="12.小结"></a>12.小结</h2>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>程序的机器级表示</title>
    <url>/2021/04/27/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><h2 id="1-历史观点"><a href="#1-历史观点" class="headerlink" title="1.历史观点"></a>1.历史观点</h2><h2 id="2-程序编码"><a href="#2-程序编码" class="headerlink" title="2.程序编码"></a>2.程序编码</h2><h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><ul>
<li><p>指令集体系结构</p>
<p>定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响</p>
</li>
<li><p>内存地址是虚拟地址</p>
<p>提供的内存模型看上去是一个非常大的字节数组</p>
</li>
<li><p>程序计数器（%rip）</p>
<p>给出将要执行的下一条指令在内存中的地址。</p>
</li>
<li><p>整数寄存器文件</p>
</li>
<li><p>条件码寄存器</p>
</li>
<li><p>向量寄存器</p>
</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><ul>
<li>反汇编器</li>
<li>链接器</li>
</ul>
<h3 id="关于格式的注解"><a href="#关于格式的注解" class="headerlink" title="关于格式的注解"></a>关于格式的注解</h3><h2 id="3-数据格式"><a href="#3-数据格式" class="headerlink" title="3.数据格式"></a>3.数据格式</h2><h3 id="字（16位）"><a href="#字（16位）" class="headerlink" title="字（16位）"></a>字（16位）</h3><p>大多数GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。</p>
<h2 id="4-访问信息"><a href="#4-访问信息" class="headerlink" title="4.访问信息"></a>4.访问信息</h2><p>一个x86-64 的中央处理单元(CPU) 包含一组16 个存储64 位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。<br>%rax 到 %rbp，%r8 到 %r15 。</p>
<p>栈指针%rsp，用来指明运行时栈的结束位置</p>
<p>当这些指令以寄存器作为目标时，对于生成小于8 字节结果的指令，对此有两条规则:<br>生成1 字节和2 字节数字的指令会保持剩下的字节不变;<br>生成4 字节数字的指令会把高位4 个字节置为0 。</p>
<h3 id="操作数-operand-指示符"><a href="#操作数-operand-指示符" class="headerlink" title="操作数(operand)指示符"></a>操作数(operand)指示符</h3><p>指示出执行一个操作中要使用的源数据<br>值，以及放置结果的目的位置。</p>
<ul>
<li><p>立即数</p>
<p>表示常数值<br>立即数的书写方式是， $后面跟一个用标准C 表示法表示的整数，比如， $-577 或$0x1f</p>
</li>
<li><p>寄存器</p>
<p>用符号ra 来表示任意寄存器a ，用引用R[ra]来表示它的值</p>
</li>
<li><p>内存引用</p>
<p>会根据计算出来的地址(通常称为有效地址)访问某个内存位置。<br>Mb[Addr] 表示对存储在内存中从地址Addr 开始的b 个字节值的引用</p>
<ul>
<li><p>寻址模式</p>
<p>允许不同形式的内存引用<br>表中底部用语法<br>Imm( rb,ri,s) 表示的是最常用的形式</p>
<p>一个立即数偏移lmm ， 一个基址寄存器rb，一个变址寄存器ri 和一个比例因子s，这里s 必须是1 、2 、4 或者8。基址和变址寄存器都必须是64 位寄存器。有效地址被计算为<br>Imm+ R[ rb] +R[ri] * s 。<br>引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些部分。</p>
</li>
</ul>
</li>
</ul>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。</p>
<ul>
<li><p>MOV类</p>
<p>MOV   S ,  D</p>
<p>movb （1字节）<br>movw  （2字节）<br>movl  （4字节） 以寄存器为目的时，会把高位4字节置0<br>movq  （8字节）</p>
<p>源操作数指定的值是一个立即数，存储在寄存器中或者内存中。<br>目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。<br>传送指令的两个操作数不能都指向内存位置。</p>
<ul>
<li>MOVZ类</li>
<li>MOVS类</li>
</ul>
</li>
</ul>
<h3 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h3><ul>
<li><p>四字（64位）压栈</p>
<p>栈指针减 8，将新的值写到栈顶</p>
</li>
<li><p>四字出栈</p>
<p>从栈顶读出数据，然后栈指针加 8</p>
</li>
</ul>
<h2 id="5-算术和逻辑"><a href="#5-算术和逻辑" class="headerlink" title="5.算术和逻辑"></a>5.算术和逻辑</h2><p>操作对象：字节、字、双字、四字<br>操作类型：加载有效地址、一元操作、二元操作、移位</p>
<h3 id="加载有效地址（leaq）"><a href="#加载有效地址（leaq）" class="headerlink" title="加载有效地址（leaq）"></a>加载有效地址（leaq）</h3><p>movq指令的变形，它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读人数据，而是将有效地址写入到目的操作数。</p>
<h3 id="一元操作和二元操作"><a href="#一元操作和二元操作" class="headerlink" title="一元操作和二元操作"></a>一元操作和二元操作</h3><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><h3 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h3><p>乘<br>除</p>
<h2 id="6-控制"><a href="#6-控制" class="headerlink" title="6.控制"></a>6.控制</h2><h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>CF：进位标志<br>ZF：零标志<br>SF：符号标志<br>OF：溢出标志<br>比较和测试指令</p>
<h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>直接跳转<br>间接跳转</p>
<h3 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h3><h3 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h3><p>通常使用，但是低效</p>
<h3 id="用条件传送来实现条件分支"><a href="#用条件传送来实现条件分支" class="headerlink" title="用条件传送来实现条件分支"></a>用条件传送来实现条件分支</h3><p>比条件控制高效，因为流水线、分支预测<br>但是受限，能使用的地方较少</p>
<h3 id="循环（条件测试-跳转）"><a href="#循环（条件测试-跳转）" class="headerlink" title="循环（条件测试 + 跳转）"></a>循环（条件测试 + 跳转）</h3><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><h2 id="7-过程"><a href="#7-过程" class="headerlink" title="7.过程"></a>7.过程</h2><p>过程的形式：函数、方法、子例程、处理函数等<br>过程的机器级支持：传递控制、传递数据、分配和释放内存</p>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>栈帧</p>
<h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><p>call</p>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p>参数数量小于等于6，寄存器<br>大于6，需要用到栈</p>
<h3 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h3><p>有些时候，局部数据必须放在内存中<br>a .数量大于6<br>b. 用到了&amp;<br>c. 数组或结构</p>
<h3 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h3><p>被调用者保存寄存器，rbx  ,rbp  ,  r12~r15<br>调用者保存寄存器</p>
<h3 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h3><h2 id="8-数组分配和访问"><a href="#8-数组分配和访问" class="headerlink" title="8.数组分配和访问"></a>8.数组分配和访问</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>Xa+L*i</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><h3 id="嵌套的数组"><a href="#嵌套的数组" class="headerlink" title="嵌套的数组"></a>嵌套的数组</h3><p>T D[R] [C];<br>&amp;D[ i ][ j ] = Xd +L（C*i +j )<br>C是列，L是一个数组数据包含 L 个字节</p>
<h3 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h3><h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><h2 id="9-异质的数据结构"><a href="#9-异质的数据结构" class="headerlink" title="9.异质的数据结构"></a>9.异质的数据结构</h2><p>结构（struct）<br>联合（union）</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><h2 id="10-将控制与数据结合起来"><a href="#10-将控制与数据结合起来" class="headerlink" title="10.将控制与数据结合起来"></a>10.将控制与数据结合起来</h2><h3 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h3><ul>
<li><p>每个指针都对应一个类型</p>
</li>
<li><p>每个指针都有一个值</p>
</li>
<li><p>指针用 &amp; 运算符创建</p>
</li>
<li><ul>
<li>操作符用于间接引用指针</li>
</ul>
</li>
<li><p>数组与指针紧密联系</p>
</li>
<li><p>指针的强制转换</p>
<p>只改变类型，不改变值<br>char *p<br>(int *)p + 7    ———— p + 28<br>(int *)（p + 7）    ——   p + 7</p>
</li>
<li><p>指针也可以指向函数</p>
<p>int （*f )(int *)  从f开始往外读，指向以int *为参数并返回int的函数指针<br>int * f(int *)  声明了一个函数，以int *为参数，并返回一个int *</p>
</li>
</ul>
<h3 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h3><h3 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h3><h3 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h3><ul>
<li>栈随机化</li>
<li>栈破坏检测</li>
<li>限制可执行代码区域</li>
</ul>
<h3 id="支持变长栈帧"><a href="#支持变长栈帧" class="headerlink" title="支持变长栈帧"></a>支持变长栈帧</h3><p>栈指针（没看明白，累了）</p>
<h2 id="11-浮点代码"><a href="#11-浮点代码" class="headerlink" title="11.浮点代码"></a>11.浮点代码</h2><p>% ymm0 ~ % ymm15<br>% xmm0 ~ % xmm15</p>
<h3 id="浮点传送和转换操作"><a href="#浮点传送和转换操作" class="headerlink" title="浮点传送和转换操作"></a>浮点传送和转换操作</h3><h3 id="过程中的浮点代码"><a href="#过程中的浮点代码" class="headerlink" title="过程中的浮点代码"></a>过程中的浮点代码</h3><h3 id="浮点运算操作"><a href="#浮点运算操作" class="headerlink" title="浮点运算操作"></a>浮点运算操作</h3><h3 id="定义和使用浮点常数"><a href="#定义和使用浮点常数" class="headerlink" title="定义和使用浮点常数"></a>定义和使用浮点常数</h3><h3 id="在浮点代码中使用位级操作"><a href="#在浮点代码中使用位级操作" class="headerlink" title="在浮点代码中使用位级操作"></a>在浮点代码中使用位级操作</h3><h3 id="浮点比较操作"><a href="#浮点比较操作" class="headerlink" title="浮点比较操作"></a>浮点比较操作</h3>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>机器级代码</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2021/05/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="1-客户端-服务器编程模型"><a href="#1-客户端-服务器编程模型" class="headerlink" title="1.客户端-服务器编程模型"></a>1.客户端-服务器编程模型</h2><p>每个网络应用都是基于客户端-服务器模型的。采用这个模型，一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务。<br>客户端和服务器都是进程</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>1)当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务<br>2) 服务器收到请求后，解释它，并以适当的方式操作它的资源<br>3) 服务器给客户端发送一个响应，并等待下一个请求。<br>4) 客户端收到响应并处理它</p>
<h2 id="2-网络"><a href="#2-网络" class="headerlink" title="2.网络"></a>2.网络</h2><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><ul>
<li><p>以太网</p>
<ul>
<li>电缆</li>
<li>网桥</li>
</ul>
</li>
</ul>
<h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><ul>
<li><p>英特网</p>
<ul>
<li><p>路由器</p>
</li>
<li><p>协议软件</p>
<p>命名机制：互联网络地址<br>传送机制：包（包头和有效载荷）</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-全球IP-因特网"><a href="#3-全球IP-因特网" class="headerlink" title="3.全球IP 因特网"></a>3.全球IP 因特网</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>32 位无符号整数</p>
<h3 id="英特网域名"><a href="#英特网域名" class="headerlink" title="英特网域名"></a>英特网域名</h3><h3 id="英特网连接"><a href="#英特网连接" class="headerlink" title="英特网连接"></a>英特网连接</h3><h2 id="4-套接字接口"><a href="#4-套接字接口" class="headerlink" title="4.套接字接口"></a>4.套接字接口</h2><h3 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h3><h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><h3 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a>listen 函数</h3><h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><h3 id="主机和服务的转换"><a href="#主机和服务的转换" class="headerlink" title="主机和服务的转换"></a>主机和服务的转换</h3><ul>
<li><p>getaddrinfo</p>
<p>getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构</p>
</li>
<li><p>getnameinfo</p>
<p>getnameinfo函数和getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串</p>
</li>
</ul>
<h3 id="套接字接口的辅助函数"><a href="#套接字接口的辅助函数" class="headerlink" title="套接字接口的辅助函数"></a>套接字接口的辅助函数</h3><ul>
<li><p>open_clientfd</p>
<p>客户端调用open_clientfd 建立与服务器的连接。</p>
</li>
<li><p>open_listenfd</p>
<p>调用open_listenfd 函数，服务器创建一个监听描述符，准备好接收连接请求。</p>
</li>
</ul>
<h3 id="echo-客户端和服务器的示倒"><a href="#echo-客户端和服务器的示倒" class="headerlink" title="echo 客户端和服务器的示倒"></a>echo 客户端和服务器的示倒</h3><h2 id="5-Web-服务器"><a href="#5-Web-服务器" class="headerlink" title="5.Web 服务器"></a>5.Web 服务器</h2><h3 id="Web-基础"><a href="#Web-基础" class="headerlink" title="Web 基础"></a>Web 基础</h3><p>Web 客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做HTTPC（Hypertext Transfer Protocol ，超文本传输协议)<br>Web 服务和常规的文件检索服务(例如FTP) 有什么区别呢?主要的区别是Web 内容可以用一种叫做HTMLC（Hypertext Markup Language ，超文本标记语言)的语言来编写。<br>然而， HTML 真正的强大之处在于一个页面可以包含指针(超链接) ，这些指针可以指向存放在任何因特网主机上的内容</p>
<h3 id="Web-内容"><a href="#Web-内容" class="headerlink" title="Web 内容"></a>Web 内容</h3><p>对于Web 客户端和服务器而言，内容是与一个MIME (Multipurpose Internet Mail Extensions ，多用途的网际邮件扩充协议)类型相关的字节序列</p>
<h3 id="HTTP-事务"><a href="#HTTP-事务" class="headerlink" title="HTTP 事务"></a>HTTP 事务</h3><p>因为HTTP 是基于在因特网连接上传送的文本行的，我们可以使用Linux 的TELNET程序来和因特网上的任何Web 服务器执行事务。<br>（很多概念，没看完）</p>
<h3 id="服务动态内容"><a href="#服务动态内容" class="headerlink" title="服务动态内容"></a>服务动态内容</h3><p>CGI</p>
<ul>
<li>害户端如何将程序参数传递给服务器</li>
<li>服务器如何将参数传递给子进程</li>
<li>服务器如何将其他信息传递给子进程</li>
<li>子进程将它的输出发送到哪里</li>
</ul>
<h2 id="6-综合-TINY-Web-服务器"><a href="#6-综合-TINY-Web-服务器" class="headerlink" title="6.综合:TINY Web 服务器"></a>6.综合:TINY Web 服务器</h2><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h2>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存</title>
    <url>/2021/05/12/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>地址空间的概念清楚地区分了数据对象(字节)和它们的属性(地址)。</p>
<p>允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想</p>
<p>主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
<h2 id="1-物理和虚拟寻址"><a href="#1-物理和虚拟寻址" class="headerlink" title="1.物理和虚拟寻址"></a>1.物理和虚拟寻址</h2><h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>虚拟地址—物理地址</p>
<h3 id="内存管理单元（MMU）"><a href="#内存管理单元（MMU）" class="headerlink" title="内存管理单元（MMU）"></a>内存管理单元（MMU）</h3><h2 id="2-地址空间"><a href="#2-地址空间" class="headerlink" title="2.地址空间"></a>2.地址空间</h2><h2 id="3-虚拟内存作为缓存的工具"><a href="#3-虚拟内存作为缓存的工具" class="headerlink" title="3.虚拟内存作为缓存的工具"></a>3.虚拟内存作为缓存的工具</h2><p>未分配的<br>已缓存的<br>已分配未缓存的</p>
<h3 id="DRAM组织的缓存结构"><a href="#DRAM组织的缓存结构" class="headerlink" title="DRAM组织的缓存结构"></a>DRAM组织的缓存结构</h3><p>用术语SRAM 缓存来表示位于CPU 和主存之间的L1、L2 和L3 高速缓存<br>用术语DRAM 缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>将虚拟页映射到物理页</p>
<h3 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h3><h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><h3 id="分配页面"><a href="#分配页面" class="headerlink" title="分配页面"></a>分配页面</h3><h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><h2 id="4-虚拟内存作为内存管理的工具"><a href="#4-虚拟内存作为内存管理的工具" class="headerlink" title="4.虚拟内存作为内存管理的工具"></a>4.虚拟内存作为内存管理的工具</h2><h2 id="5-虚拟内存作为内存保护的工具"><a href="#5-虚拟内存作为内存保护的工具" class="headerlink" title="5.虚拟内存作为内存保护的工具"></a>5.虚拟内存作为内存保护的工具</h2><h2 id="6-地址翻译（要重看）"><a href="#6-地址翻译（要重看）" class="headerlink" title="6.地址翻译（要重看）"></a>6.地址翻译（要重看）</h2><h3 id="结合高速缓存和虚拟内存"><a href="#结合高速缓存和虚拟内存" class="headerlink" title="结合高速缓存和虚拟内存"></a>结合高速缓存和虚拟内存</h3><h3 id="利用TLB-加速地址翻译"><a href="#利用TLB-加速地址翻译" class="headerlink" title="利用TLB 加速地址翻译"></a>利用TLB 加速地址翻译</h3><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><h3 id="综合-：端到端的地址翻译"><a href="#综合-：端到端的地址翻译" class="headerlink" title="综合:：端到端的地址翻译"></a>综合:：端到端的地址翻译</h3><h2 id="7-案例研究-Intel-Core-i7-Li-nux-内存系统"><a href="#7-案例研究-Intel-Core-i7-Li-nux-内存系统" class="headerlink" title="7.案例研究: Intel Core i7/ Li nux 内存系统"></a>7.案例研究: Intel Core i7/ Li nux 内存系统</h2><h3 id="Core-i7-地址翻译"><a href="#Core-i7-地址翻译" class="headerlink" title="Core i7 地址翻译"></a>Core i7 地址翻译</h3><h3 id="Linux虚拟内存系统"><a href="#Linux虚拟内存系统" class="headerlink" title="Linux虚拟内存系统"></a>Linux虚拟内存系统</h3><h2 id="8-内存映射"><a href="#8-内存映射" class="headerlink" title="8.内存映射"></a>8.内存映射</h2><h3 id="再看共享对象"><a href="#再看共享对象" class="headerlink" title="再看共享对象"></a>再看共享对象</h3><h3 id="再看fork函数"><a href="#再看fork函数" class="headerlink" title="再看fork函数"></a>再看fork函数</h3><h3 id="再看execve函数"><a href="#再看execve函数" class="headerlink" title="再看execve函数"></a>再看execve函数</h3><h3 id="使用mmap-函数的用户级内存映射"><a href="#使用mmap-函数的用户级内存映射" class="headerlink" title="使用mmap 函数的用户级内存映射"></a>使用mmap 函数的用户级内存映射</h3><h2 id="9-动态内存分配"><a href="#9-动态内存分配" class="headerlink" title="9.动态内存分配"></a>9.动态内存分配</h2><p>显式分配器<br>隐式分配器</p>
<h3 id="malloc和free-显式"><a href="#malloc和free-显式" class="headerlink" title="malloc和free(显式)"></a>malloc和free(显式)</h3><h3 id="为什么要使用动态内存分配"><a href="#为什么要使用动态内存分配" class="headerlink" title="为什么要使用动态内存分配"></a>为什么要使用动态内存分配</h3><h3 id="分配器的要求和目标"><a href="#分配器的要求和目标" class="headerlink" title="分配器的要求和目标"></a>分配器的要求和目标</h3><h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>内部碎片<br>外部碎片</p>
<h3 id="实现问题"><a href="#实现问题" class="headerlink" title="实现问题"></a>实现问题</h3><h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><h3 id="放置已分配的块"><a href="#放置已分配的块" class="headerlink" title="放置已分配的块"></a>放置已分配的块</h3><h3 id="分割空闲块"><a href="#分割空闲块" class="headerlink" title="分割空闲块"></a>分割空闲块</h3><h3 id="获取额外的堆内存"><a href="#获取额外的堆内存" class="headerlink" title="获取额外的堆内存"></a>获取额外的堆内存</h3><h3 id="合并空闲块"><a href="#合并空闲块" class="headerlink" title="合并空闲块"></a>合并空闲块</h3><h3 id="带边界标记的合并"><a href="#带边界标记的合并" class="headerlink" title="带边界标记的合并"></a>带边界标记的合并</h3><h3 id="综合：-实现一个简单的分配器"><a href="#综合：-实现一个简单的分配器" class="headerlink" title="综合：:实现一个简单的分配器"></a>综合：:实现一个简单的分配器</h3><h3 id="显示空闲链表"><a href="#显示空闲链表" class="headerlink" title="显示空闲链表"></a>显示空闲链表</h3><h3 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h3><ul>
<li>简单分离存储</li>
<li>分离适配</li>
<li>伙伴系统</li>
</ul>
<h2 id="10-垃圾收集"><a href="#10-垃圾收集" class="headerlink" title="10.垃圾收集"></a>10.垃圾收集</h2><h3 id="垃圾收集器的基本知识"><a href="#垃圾收集器的基本知识" class="headerlink" title="垃圾收集器的基本知识"></a>垃圾收集器的基本知识</h3><h3 id="Mark-amp-Sweep-垃圾收集器"><a href="#Mark-amp-Sweep-垃圾收集器" class="headerlink" title="Mark &amp; Sweep 垃圾收集器"></a>Mark &amp; Sweep 垃圾收集器</h3><h2 id="11-C程序中常见的与内存有关的错误"><a href="#11-C程序中常见的与内存有关的错误" class="headerlink" title="11.C程序中常见的与内存有关的错误"></a>11.C程序中常见的与内存有关的错误</h2><h3 id="间接引用坏指针"><a href="#间接引用坏指针" class="headerlink" title="间接引用坏指针"></a>间接引用坏指针</h3><h3 id="读未初始化的内存"><a href="#读未初始化的内存" class="headerlink" title="读未初始化的内存"></a>读未初始化的内存</h3><h3 id="允许栈缓冲区溢出"><a href="#允许栈缓冲区溢出" class="headerlink" title="允许栈缓冲区溢出"></a>允许栈缓冲区溢出</h3><h3 id="假设指针和它们指向的对象是相同大小的"><a href="#假设指针和它们指向的对象是相同大小的" class="headerlink" title="假设指针和它们指向的对象是相同大小的"></a>假设指针和它们指向的对象是相同大小的</h3><h3 id="造成错位错误"><a href="#造成错位错误" class="headerlink" title="造成错位错误"></a>造成错位错误</h3><h3 id="引用指针，而不是它所指向的对象"><a href="#引用指针，而不是它所指向的对象" class="headerlink" title="引用指针，而不是它所指向的对象"></a>引用指针，而不是它所指向的对象</h3><h3 id="误解指针运算"><a href="#误解指针运算" class="headerlink" title="误解指针运算"></a>误解指针运算</h3><h3 id="引用不存在的变量"><a href="#引用不存在的变量" class="headerlink" title="引用不存在的变量"></a>引用不存在的变量</h3><h3 id="引用空闲堆块中的数据"><a href="#引用空闲堆块中的数据" class="headerlink" title="引用空闲堆块中的数据"></a>引用空闲堆块中的数据</h3><h3 id="引起内存泄漏"><a href="#引起内存泄漏" class="headerlink" title="引起内存泄漏"></a>引起内存泄漏</h3><h2 id="12-小结"><a href="#12-小结" class="headerlink" title="12.小结"></a>12.小结</h2>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>虚拟内存</tag>
      </tags>
  </entry>
  <entry>
    <title>链接</title>
    <url>/2021/05/12/%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>链接(linking) 是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行</p>
<h2 id="1-编译器驱动程序"><a href="#1-编译器驱动程序" class="headerlink" title="1.编译器驱动程序"></a>1.编译器驱动程序</h2><h2 id="2-静态链接"><a href="#2-静态链接" class="headerlink" title="2.静态链接"></a>2.静态链接</h2><p>符号解析<br>重定位</p>
<h2 id="3-目标文件"><a href="#3-目标文件" class="headerlink" title="3.目标文件"></a>3.目标文件</h2><p>编译器和汇编器生成可重定位目标文件(包括共享目标文件)。<br>链接器生成可执行目标文件。</p>
<h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><h3 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h3><h3 id="共享目标文件"><a href="#共享目标文件" class="headerlink" title="共享目标文件"></a>共享目标文件</h3><h2 id="4-可重定位目标文件"><a href="#4-可重定位目标文件" class="headerlink" title="4.可重定位目标文件"></a>4.可重定位目标文件</h2><h2 id="5-符号和符号表"><a href="#5-符号和符号表" class="headerlink" title="5.符号和符号表"></a>5.符号和符号表</h2><h3 id="全局符号"><a href="#全局符号" class="headerlink" title="全局符号"></a>全局符号</h3><h3 id="外部符号"><a href="#外部符号" class="headerlink" title="外部符号"></a>外部符号</h3><h3 id="局部符号"><a href="#局部符号" class="headerlink" title="局部符号"></a>局部符号</h3><h2 id="6-符号解析"><a href="#6-符号解析" class="headerlink" title="6.符号解析"></a>6.符号解析</h2><h3 id="链接器如何解析多重定义的全局符号"><a href="#链接器如何解析多重定义的全局符号" class="headerlink" title="链接器如何解析多重定义的全局符号"></a>链接器如何解析多重定义的全局符号</h3><p>强符号<br>弱符号</p>
<h3 id="与静态库链接"><a href="#与静态库链接" class="headerlink" title="与静态库链接"></a>与静态库链接</h3><h3 id="链接器如何使用静态库来解析引用"><a href="#链接器如何使用静态库来解析引用" class="headerlink" title="链接器如何使用静态库来解析引用"></a>链接器如何使用静态库来解析引用</h3><h2 id="7-重定位"><a href="#7-重定位" class="headerlink" title="7.重定位"></a>7.重定位</h2><h3 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h3><h3 id="重定位符号引用"><a href="#重定位符号引用" class="headerlink" title="重定位符号引用"></a>重定位符号引用</h3><h2 id="8-可执行目标文件"><a href="#8-可执行目标文件" class="headerlink" title="8.可执行目标文件"></a>8.可执行目标文件</h2><h2 id="9-加载可执行目标文件"><a href="#9-加载可执行目标文件" class="headerlink" title="9.加载可执行目标文件"></a>9.加载可执行目标文件</h2><h2 id="10-动态链接共享库"><a href="#10-动态链接共享库" class="headerlink" title="10.动态链接共享库"></a>10.动态链接共享库</h2><h2 id="11-从应用程序中加载和链接共享库"><a href="#11-从应用程序中加载和链接共享库" class="headerlink" title="11.从应用程序中加载和链接共享库"></a>11.从应用程序中加载和链接共享库</h2><h2 id="12-位置无关代码"><a href="#12-位置无关代码" class="headerlink" title="12.位置无关代码"></a>12.位置无关代码</h2><h2 id="13-库打桩机制"><a href="#13-库打桩机制" class="headerlink" title="13.库打桩机制"></a>13.库打桩机制</h2><p>它允许你截获对共享库函数的调用，取而代之执行自己的代码</p>
<h3 id="编译时打桩"><a href="#编译时打桩" class="headerlink" title="编译时打桩"></a>编译时打桩</h3><p>访问程序的源代码</p>
<h3 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h3><p>访问程序的可重定位程序文件</p>
<h3 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h3><p>访问可执行目标文件</p>
<h2 id="14-处理目标文件的工具"><a href="#14-处理目标文件的工具" class="headerlink" title="14.处理目标文件的工具"></a>14.处理目标文件的工具</h2><p>GNU binutils</p>
<h2 id="15-小结"><a href="#15-小结" class="headerlink" title="15.小结"></a>15.小结</h2>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>PCI总线设备</title>
    <url>/2021/04/24/PCI%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h1 id="PCI总线设备"><a href="#PCI总线设备" class="headerlink" title="PCI总线设备"></a>PCI总线设备</h1><h2 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线"></a>PCI总线</h2><p>​       PCI是外围设备互连（Peripheral Component Interconnect）的简称，作为一种通用的总线标准接口。</p>
<p>​       PCI总线具有3个非常显著的优点：</p>
<ol>
<li>在计算机和外设间传输数据时具有很好的性能</li>
<li>能够尽量独立于具体的平台</li>
<li>可以很方便地实现即插即用</li>
</ol>
<h2 id="PCI设备"><a href="#PCI设备" class="headerlink" title="PCI设备"></a>PCI设备</h2><p>​       PCI总线架构中可以包含多个PCI设备，由于一个PCI接口卡上可能包含多个功能模块，每个模块都被当做独立的逻辑设备。因此，每个PCI功能即PCI逻辑设备都唯一地对应一个pci_dev设备描述符，该结构体的具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">global_list</span>;</span></span><br><span class="line">    <span class="comment">/*全局链表元素globa_list:每一个pci_dev结构都通过该成员连接到全局pci设备pci_devices中*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">bus_list</span>;</span></span><br><span class="line">    <span class="comment">/*总线列表元素bus_list:每一个pci_dev结构除了连接到全局设备链表中，还会通过这个成员连接到其所属PCI总线的设备列表中。每一条PCI总线都维护一条自己的设备链表视图，以便描述所有连接在该PCI总线上的设备，其表头由PC总线的pci_bus结构中的devices成员所描述。 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_bus</span> * <span class="title">bus</span>;</span></span><br><span class="line">    <span class="comment">/*总线指针bus:指向这个PCI设备所在的PCI总线的pci_bus结构。因此，对于桥设备，bus指针将指向桥设备的主总线（primary bus），也即指向桥设备所在的PCI总线。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_bus</span> * <span class="title">subordinate</span>;</span></span><br><span class="line">    <span class="comment">/*指针subordinate：指向这个PCI设备所桥接的下级总线。这个指针仅对桥设备有意义，对于一般的非桥PC设备，该指针成员总是为NULL。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> * sysdata;</span><br><span class="line">    <span class="comment">/*无类型指针sysdata：指向一片特定于系统的扩展数据。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pro_dir_entry</span> * <span class="title">procent</span>;</span></span><br><span class="line">    <span class="comment">/*指针procent：指向该PCI设备在/proc文件系统中对应的目录项。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> devfn;</span><br><span class="line">    <span class="comment">/*devfn：PCI设备的设备功能号，也称PCI逻辑设备号（0~255）。其中bit[7:3]是物理设备号（取值范围0~31），其中bit[2:0]是功能号（取值范围0~7）。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> vendor;</span><br><span class="line">    <span class="comment">/*vendor：16位无符号整数，表示PCI设备的厂商ID。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> device;</span><br><span class="line">    <span class="comment">/*vendor：16位无符号整数，表示PCI设备的设备ID。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> subsystem_vendor;</span><br><span class="line">    <span class="comment">/*subsystem_vendor：16位无符号整数，表示PCI设备的子系统厂商ID。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> subsystem_device;</span><br><span class="line">    <span class="comment">/*subsystem_device：16位无符号整数，表示PCI设备的子系统设备ID。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    <span class="comment">/*class：32位的无符号整数，表示该PCI设备的类别，其中bit[7:0]为编程接口，bit[15:8]为子类别代码，bit[23:16]为基类别代码，bit[31:24]无意义。显然，class成员的低3位字节刚好对应于PCI配置空间中的类代码。*/</span></span><br><span class="line">    </span><br><span class="line">    u8 hdr_type;</span><br><span class="line">    <span class="comment">/*hdr_type：8位无符号整数，表示PCI配置空间头部的类型。其中，bit[7]=1表示多功能设备，bit[7]=0表示单功能设备。bit[6:0]表示PCI控制空间头部的布局类型，值00h表示一般PCI设备的配置空间头部，值01h表示PCI-to-PCI桥的配置空间头部，值02h表示CardBus桥的配置空间头部。*/</span></span><br><span class="line">    </span><br><span class="line">    u8 rom_base_reg;</span><br><span class="line">    <span class="comment">/*rom_base_reg：8位无符号整数，表示PCI配置空间中的ROM基地址寄存器在PCI配置空间中的位置。ROM基地址寄存器在不同类型的PCI配置空间头部的位置是不一样的，对于type0的配置空间布局，ROM基地址寄存器的起始位置是30h；对于PCI-to-PCI桥所用的type1配置空间布局，ROM基地址寄存器的起始位置是38h。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> * <span class="title">driver</span>;</span></span><br><span class="line">    <span class="comment">/*指针driver：指向这个PCI设备所对应的驱动程序定义的pci_driver结构。每一个pci设备驱动程序都必须对定义自己的pci_driver结构进行描述。*/</span></span><br><span class="line">    </span><br><span class="line">    u64 dma_mask;</span><br><span class="line">    <span class="comment">/*dma_mask：用于DMA的总线地址掩码，一般来说，这个成员的值是0xffffffff。数据类型dma_attr_t定义在</span></span><br><span class="line"><span class="comment">    include/asm/types.h中，在x86平台上，dma_attr_t类型就是u32类型。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pci_power_t</span> current_state;</span><br><span class="line">    <span class="comment">/*当前操作状态*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">    <span class="comment">/*通用的设备接口*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> vendor_compatible[DEVICE_COUNT_COMPATIBLE];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> device_compatible[DEVICE_COUNT_COMPATIBLE];</span><br><span class="line">    <span class="comment">/*定义这个PCI设备与哪些设备兼容*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> irq;</span><br><span class="line">    <span class="comment">/*无符号的整数irq：表示PCI设备通过哪根IRQ输入线产生中断，一般为0~15之间的某个值。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">resource</span>[<span class="title">DEVICE_COUNT_RESOURCE</span>];</span></span><br><span class="line">    <span class="comment">/*表示该设备可能用到的资源，包括：I/O端口区域、设备内存地址区域及扩展ROM地址区域。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cfg_size;</span><br><span class="line">    <span class="comment">/*配置空间的大小*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> transparent:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*透明PCI桥*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> multifunction:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*多功能设备*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> enabled:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*pci_enable_device已经被调用*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> is_busmaster:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*设备是主设备*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> no_msi:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*设备不使用msi*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> block_ucfg_access:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*配置空间访问用块的方式*/</span></span><br><span class="line">    </span><br><span class="line">    u32 saved_config_space[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">/*在挂起时保存配置空间*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> * <span class="title">rom_attr</span>;</span></span><br><span class="line">    <span class="comment">/*sysfs ROM入口的属性描述*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rom_attr_enabled;</span><br><span class="line">    <span class="comment">/*能显示rom属性*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> * <span class="title">res_attr</span>[<span class="title">DEVICE_COUNT_RESOURCE</span>];</span></span><br><span class="line">    <span class="comment">/*资源的sysfs文件*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="PCI设备驱动结构"><a href="#PCI设备驱动结构" class="headerlink" title="PCI设备驱动结构"></a>PCI设备驱动结构</h1><p>​        PCI设备上有3种地址空间：PCI的I/O空间、存储空间和配置空间。CPU可以访问PCI设备上的所有地址空间，其中I/O空间和存储空间提供给设备驱动程序使用，配置空间由linux内核中的PCI初始化代码使用。内核在启动时负责对所有PCI设备进行初始化，配置好所有的PCI设备，包括中断号及I/O基址，并在文件/proc/pci中列出所有找到的PCI设备，以及这些设备的参数和属性。linux驱动程序通常使用结构（struct）表示一种设备，结构体中的变量代表某一具体设备，该变量存放了与该设备相关的所有信息。好的驱动程序应该能驱动多个同种设备，每个设备之间用次设备号进行区分，如果采用结构数据代表所有该驱动程序的设备，就可以简单的使用数组下标表示次设备号。</p>
<h2 id="pci-driver"><a href="#pci-driver" class="headerlink" title="pci_driver"></a>pci_driver</h2><p>​         这个数据结构在文件include/linux/pci.h里，这是linux内核2.4版本之后为新型的PCI设备驱动程序添加的。其中，最主要的是用于识别设备的id_table结构，以及用于检测设备的函数probe()和卸载设备的函数remove()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct <span class="title">pci_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> * <span class="title">id_table</span>;</span></span><br><span class="line">    <span class="keyword">int</span> (*probe) (struct pci_dev * dev,<span class="keyword">const</span> struct pci_device_id * id);</span><br><span class="line">    <span class="keyword">void</span> (*remove) (struct pci_dev *dev);</span><br><span class="line">    <span class="keyword">int</span> (*save_state) (struct pci_dev *dev,u32 state);</span><br><span class="line">    <span class="keyword">int</span> (*resume) (struct pci_dev *dev);</span><br><span class="line">    <span class="keyword">int</span> (*enable_wake) (struct pci_dev *dev,u32 state,<span class="keyword">int</span> enable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pci-dev"><a href="#pci-dev" class="headerlink" title="pci_dev"></a>pci_dev</h2><p>​        这个数据结构也在文件include/linuc/pci.h里，详细描述了一个PCI设备几乎所有的硬件信息，包括厂商ID、设备ID及其它各种资源。（参见PCI设备章节对该结构体的详细解释）</p>
<h1 id="PCI设备驱动实例"><a href="#PCI设备驱动实例" class="headerlink" title="PCI设备驱动实例"></a>PCI设备驱动实例</h1><h2 id="PCI设备驱动程序基本框架"><a href="#PCI设备驱动程序基本框架" class="headerlink" title="PCI设备驱动程序基本框架"></a>PCI设备驱动程序基本框架</h2><p>​        用模块方式实现PCI设备驱动程序时，通常要实现一下几个部分：初始化设备模块、设备打开模块、数据读写和控制模块、中断处理模块、设备释放模块及设备卸载模块等。下面是一个典型的PCI设备驱动程序的基本框架：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*指明该驱动程序适用于哪一些PCI设备*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> <span class="title">demo_pci_tbl</span>[] _<span class="title">initdata</span>  =</span>   &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        PCI_VENDOR_ID_DEMO,</span><br><span class="line">        PCI_DEVICE_ID_DEMO,</span><br><span class="line">        PCI_ANY_ID,</span><br><span class="line">        PCI_ANY_ID,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        DEMO</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,&#125;</span><br><span class="line">&#125;  ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对特定PCI设备进行描述的结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">demo_card</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="comment">/*使用链表保存所有同类的PCI设备*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">demo_card</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断处理模块*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo_interrupt</span><span class="params">(<span class="keyword">int</span> irq,<span class="keyword">void</span>  * dev_id,struct pt_regs * regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备文件操作接口*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">demo_fops</span> =</span> &#123;</span><br><span class="line">    owner: THIS_MODULE,                      <span class="comment">//demo_fops所属的设备模块</span></span><br><span class="line">    read : demo_read,                        <span class="comment">//读设备操作</span></span><br><span class="line">    write：demo_write,                       <span class="comment">//写设备操作</span></span><br><span class="line">    ioctl: demo_ioctl,                       <span class="comment">//控制设备操作</span></span><br><span class="line">    mmap : demo_mmap,                        <span class="comment">//内存重映射操作</span></span><br><span class="line">    open : demo _open,                       <span class="comment">//打开设备操作</span></span><br><span class="line">    release : demo_release                   <span class="comment">//释放设备操作</span></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备模块信息*/</span></span><br><span class="line"><span class="keyword">static</span>  <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">demo_pci_driver</span> =</span> &#123;</span><br><span class="line">    name:demo_MODULE_NAME,                   <span class="comment">//设备模块名称</span></span><br><span class="line">    id_table:demo_pci_tbl,                   <span class="comment">//能够驱动的设备列表</span></span><br><span class="line">    probe:demo_probe,                        <span class="comment">//查找并初始化设备</span></span><br><span class="line">    remove:demo_remove                       <span class="comment">//卸载设备模块</span></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> _init <span class="title">demo_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> _exit <span class="title">demo_cleanup_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pci_unregister_driver(&amp;demo_pci_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*加载驱动程序模块入口*/</span></span><br><span class="line">module_init(demo_init_module);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*卸载驱动程序模块入口*/</span></span><br><span class="line">module_exit(demo_cleanup_module);</span><br></pre></td></tr></table></figure>

<p>（注意：同卸载和加载模块相关的函数或数据结构都要在前面加上_init 、__exit 等标识符，以便同普通函数区分开。）    </p>
<h2 id="初始化设备模块"><a href="#初始化设备模块" class="headerlink" title="初始化设备模块"></a>初始化设备模块</h2><p>​        linux系统下，对一个PCI设备的初始化，需要完成以下工作：</p>
<ol>
<li>检查PCI总线是否被linux内核支持。</li>
<li>检查设备是否插在总线插槽上，如果在，保存所占用插槽的位置等信息。</li>
<li>读出配置头中的信息提供给驱动程序使用。</li>
</ol>
<p>​        当linux内核启动并完成对所有PCI设备进行扫描、登录和分配资源等初始化操作时，会建立起系统中所有PCI设备的拓扑结构，此后当PCI驱动程序需要对设备进行初始化时，一般都会调用如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> _init <span class="title">demo_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*检查系统是否支持PCI总线*/</span></span><br><span class="line">    <span class="keyword">if</span>(!pci_present())</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注册硬件驱动程序*/</span></span><br><span class="line">    <span class="keyword">if</span>(pci_register_driver(&amp;demo_pci_driver))&#123;</span><br><span class="line">        pci_unregister_driver(&amp;demo_pci_driver);</span><br><span class="line">            <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;           </span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> _init <span class="title">demo_probe</span><span class="params">(struct pci_dev * pci_dev,<span class="keyword">const</span> struct pci_device_id * pci_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">demo_card</span> * <span class="title">card</span> ;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*启动PCI设备*/</span></span><br><span class="line">    <span class="keyword">if</span>(pci_enable_device(pci_dev))</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置DMA标识*/</span></span><br><span class="line">    <span class="keyword">if</span>(pci_set_dma_mask(pci_dev,DEMO_DMA_MASK))&#123;</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在内核空间中动态申请内存*/</span></span><br><span class="line">    <span class="keyword">if</span>((card = kmalloc(<span class="keyword">sizeof</span>(struct demo_card),GFP_KERNEL))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        printk(KERN_ERR<span class="string">&quot;pci_demo:out of memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(card ,<span class="number">0</span>,<span class="keyword">sizeof</span>(*card));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*读取PCI配置信息*/</span></span><br><span class="line">    card-&gt;iobase = pci_resource_start(pci_dev,<span class="number">1</span>);</span><br><span class="line">    card-&gt;pci_dev = pci_dev;</span><br><span class="line">    card-&gt;pci_id  = pci_id-&gt;device;</span><br><span class="line">    card-&gt;irq = pci_dev-&gt;irq;</span><br><span class="line">    card-&gt;next = devs;</span><br><span class="line">    card-&gt;magic = DEMO_CARD_MEGIC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置成总线主DMA模式*/</span></span><br><span class="line">    pci_set_master(pci_dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*申请I/O资源*/</span></span><br><span class="line">    request_region(card-iobase,<span class="number">64</span>,card_names[pci_id-&gt;driver_data]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打开设备模块"><a href="#打开设备模块" class="headerlink" title="打开设备模块"></a>打开设备模块</h2><p>​        打开设备模块主要实现申请中断、检查读写模式及申请对设备的控制权等。在申请控制权时，非阻塞方式遇忙返回；否则进程主动接受调度，进入睡眠状态，等待其他进程释放对设备的控制权。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">demo_open</span><span class="params">(struct inode * inode,struct file * file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*申请中断，注册中断处理程序*/</span></span><br><span class="line">    request_irq(card-&gt; irq,&amp;demo_interrupt,SA_SHIRQ,card_names[pci_id-&gt;driver_data],card));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*检查读写模式*/</span></span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_mode&amp;FMODE_READ)&#123;</span><br><span class="line">         <span class="comment">/*...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_mode&amp;FMODE_WRITE)&#123;</span><br><span class="line">        <span class="comment">/*...*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*申请对设备的控制权*/</span></span><br><span class="line">    down(&amp;card-&gt;open_sem);</span><br><span class="line">    <span class="keyword">while</span>(card-&gt;open_mode&amp;file-&gt;f_mode)&#123;</span><br><span class="line">        <span class="keyword">if</span>(file-&gt;f_flags&amp;O_NONBLOCK)&#123;</span><br><span class="line">            <span class="comment">/*NONBLOCK模式，返回 -EBUSY*/</span></span><br><span class="line">            up(card-&gt;open_sem);</span><br><span class="line">            <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">/*等待调度，获得控制权*/</span></span><br><span class="line">            card-&gt;open_mode| = f_mode&amp;(FMODE_READ|FMODE_WRITE);</span><br><span class="line">            up(&amp;card -&gt;open_sem);</span><br><span class="line">             <span class="comment">/*设备打开，计数增1*/</span></span><br><span class="line">             MOD_INC_USE_COUNT;</span><br><span class="line">             <span class="comment">/*...*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据读写和控制模块"><a href="#数据读写和控制模块" class="headerlink" title="数据读写和控制模块"></a>数据读写和控制模块</h2><p>​        PCI设备驱动程序通过demo_fops结构中的函数demo_ioctl()，向应用程序提供对硬件进行控制的接口。例如通过它可以从I/O寄存器里读取一个数据，并传送到用户空间里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">demo_ioctl</span><span class="params">(struct inode*inode,struct file*file,<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> DEMO_RDATA:</span><br><span class="line">        <span class="comment">/*从IO端口读取4字节的数据*/</span></span><br><span class="line">            val =  inl(card-&gt;iobae + <span class="number">0x10</span>);</span><br><span class="line">    <span class="comment">/*将读取的数据传输到用户空间*/</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在demo_fops里还可以实现诸如demo_read()、demo_mmap()等操作，<strong>linux内核源码中的driver目录</strong>里提供了许多设备驱动程序的源代码，那里可以找到类似的例子。在对资源的访问方式上，除了IO指令外，还有对外设IO内存的访问。对这些内存的操作，一方面可以通过把IO内存重新映射后，作为普通内存进行操作；另一方面也可以通过总线主DMA（Bus Master DMA）的方式，让设备把数据通过DMA传送到系统内存中。</p>
<h2 id="中断处理模块"><a href="#中断处理模块" class="headerlink" title="中断处理模块"></a>中断处理模块</h2><p>​        PC的中断资源比较有限，只有0~15的中断号，因此大部分外部设备都是以共享的形式申请中断号。当中断发生时，中断处理程序首先负责对中断进行识别，然后再做进一步的处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo_interrupt</span><span class="params">(<span class="keyword">int</span> irq,<span class="keyword">void</span> *dev_id,struct pt_regs*regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">demo_card</span>*<span class="title">card</span> =</span> (struct demo_card*)dev_id;</span><br><span class="line">    u32 status;</span><br><span class="line">    spin_lock(&amp;card-&gt;lock);</span><br><span class="line">    <span class="comment">/*识别中断*/</span></span><br><span class="line">    status = inl(card-&gt;iobase+GLOB_STA);</span><br><span class="line">    <span class="keyword">if</span>(!(status&amp;INT_MASK))</span><br><span class="line">    &#123;</span><br><span class="line">        spin_unlock(&amp;card-&gt;lock);   </span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">/*not for us ?????*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*告诉设备已经收到中断*/</span></span><br><span class="line">    out1(status&amp;INT_MASK,card-&gt;iobase+GLOB_STA);</span><br><span class="line">    spin_lock(&amp;card-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*其它进一步的处理，例如更新DMA缓冲区指针等*/</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="释放设备模块"><a href="#释放设备模块" class="headerlink" title="释放设备模块"></a>释放设备模块</h2><p>​        释放设备模块主要负责释放对设备的控制权，释放占用的内存和中断等，所做的事情正好和打开设备模块相反。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">demo_release</span><span class="params">(struct inode*inode,struct file*file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    card-&gt;open_mode &amp;=(FMODE_READ|FMODE_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*唤醒其它等待获取控制权的进程*/</span></span><br><span class="line">    wake_up(&amp;card-&gt;open_wait);</span><br><span class="line">    up(&amp;card-&gt;open_sem);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*释放中断*/</span></span><br><span class="line">    free_irq(card-&gt;irq,card);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设备打开计数增1*/</span></span><br><span class="line">    MOD_DEC_USE_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="卸载设备模块"><a href="#卸载设备模块" class="headerlink" title="卸载设备模块"></a>卸载设备模块</h2><p>​         卸载设备模块与初始化设备模块是相对应的，实现起来相对比较简单，主要是调用函数pci_unregister_driver()从linux内核中注销设备驱动程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> _exit <span class="title">demo_cleanup_module</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    pci_unregister_driver(&amp;demo_pci_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>​         PCI是外围设备互连（Peripheral Component Interconnect）的简称，作为一种通用的总线标准接口。<strong>每个PCI功能即PCI逻辑设备都唯一地对应一个pci_dev设备描述符</strong>。linux驱动程序通常使用结构（struct）表示一种设备，结构体中的变量代表某一具体设备，该变量存放了与该设备相关的所有信息。</p>
<p>​         用模块方式实现PCI设备驱动程序时，通常要实现一下几个部分：初始化设备模块、设备打开模块、数据读写和控制模块、中断处理模块、设备释放模块及设备卸载模块等。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>驱动</category>
      </categories>
      <tags>
        <tag>PCI</tag>
      </tags>
  </entry>
  <entry>
    <title>异常控制流</title>
    <url>/2021/05/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<h1 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h1><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h2><p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。<br>异常( exception) 就是控制流中的突变，用来响应处理器状态中的某些变化。<br>事件<br>异常表</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>异常号</li>
<li>异常表</li>
<li>异常表基址寄存器</li>
</ul>
<h3 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h3><ul>
<li><p>中断</p>
<p>中断是异步发生的，是来自处理器外部的I/ O 设备的信号的结果。<br>硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。<br>中断处理程序<br>将控制返回到下一条指令</p>
</li>
<li><p>陷阱</p>
<p>陷阱是有意的异常，是执行一条指令的结果<br>将控制返回到下一条指令<br>最重要的用途是系统调用<br>syscall</p>
</li>
<li><p>故障</p>
<p>故障由错误情况引起，它可能能够被故障处理程序修正<br>要么重新执行当前指令，要么终止</p>
</li>
<li><p>终止</p>
<p>不可恢复的致命错误造成的结果，通常是硬件错误<br>abort</p>
</li>
</ul>
<h3 id="Linux-x86-64-系统中的异常"><a href="#Linux-x86-64-系统中的异常" class="headerlink" title="Linux/x86-64 系统中的异常"></a>Linux/x86-64 系统中的异常</h3><ul>
<li><p>Linux/x86-64 故障和终止</p>
<p>除法错误（0）<br>一般保护故障（13）（段错误）<br>缺页（14）<br>机器检查（18）</p>
</li>
<li><p>Linux/86-64 系统调用</p>
<p>系统级函数</p>
</li>
</ul>
<h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h2><p>异常是允许操作系统内核提供进程( process) 概念的基本构造块<br>关键抽象：一个独立的逻辑控制流（好像程序独占的使用处理器），一个私有的地址空间（好像程序独占的使用内存系统）</p>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><h3 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h3><p>一个逻辑流的执行在时间上与另一个流重叠，称为并发流</p>
<h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><p>模式位<br>进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。<br>当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>操作系统内核使用一种称为上下文切换（context switch) 的较高层形式的异常控制流来实现多任务。<br>上下文切换机制是建立在8. 1 节中已经讨论过的那些较低层异常机制之上的<br>上下文切换1)保存当前进程的上下文， 2) 恢复某个先前被抢占的进程被保存的上下文， 3) 将控制传递给这个新恢复的进程。</p>
<h2 id="3-系统调用错误处理"><a href="#3-系统调用错误处理" class="headerlink" title="3.系统调用错误处理"></a>3.系统调用错误处理</h2><p>错误处理包装函数<br>Fork（）</p>
<h2 id="4-进程控制"><a href="#4-进程控制" class="headerlink" title="4.进程控制"></a>4.进程控制</h2><p>从C程序中操作进程的系统调用</p>
<h3 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h3><p>进程PID<br>pid_t getpid(void);   //获取进程ID<br>pid_t getppid(void);  //获取父进程ID</p>
<h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><p>进程总是处在下面三种状态之一：运行、停止（挂起）、终止</p>
<p>父进程通过调用fork函数创建一个新的运行的子进程</p>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>pid_t waitpid(pid_t pid , int *statusp , int options);</p>
<h3 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h3><p>sleep<br>pause</p>
<h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><p>execve<br>execve 调用一次并从不返回。</p>
<h3 id="利用fork-和execve-运行程序"><a href="#利用fork-和execve-运行程序" class="headerlink" title="利用fork 和execve 运行程序"></a>利用fork 和execve 运行程序</h3><h2 id="5-信号"><a href="#5-信号" class="headerlink" title="5.信号"></a>5.信号</h2><h3 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h3><ul>
<li>发送信号</li>
<li>接收信号</li>
</ul>
<h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><ul>
<li>进程组</li>
<li>用/bin/kill 程序发送信号</li>
<li>从键盘发送信号</li>
<li>用kill 函数发送信号</li>
<li>用alarm 函数发送信号</li>
</ul>
<h3 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h3><h3 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h3><h3 id="编写信号处理程序"><a href="#编写信号处理程序" class="headerlink" title="编写信号处理程序"></a>编写信号处理程序</h3><ul>
<li><p>安全的信号处理</p>
<p>使得处理程序尽可能简单，调用安全函数，保存和恢复errno ，保护对共享数据结构的访问，并使用volatile 和sig_atomic_t</p>
</li>
<li><p>正确的信号处理</p>
</li>
<li><p>可移植的信号处理</p>
</li>
</ul>
<h3 id="同步流以避免讨厌的并发错误"><a href="#同步流以避免讨厌的并发错误" class="headerlink" title="同步流以避免讨厌的并发错误"></a>同步流以避免讨厌的并发错误</h3><h3 id="显式地等待信号"><a href="#显式地等待信号" class="headerlink" title="显式地等待信号"></a>显式地等待信号</h3><h2 id="6-非本地跳转"><a href="#6-非本地跳转" class="headerlink" title="6.非本地跳转"></a>6.非本地跳转</h2><h2 id="7-操作进程的工具"><a href="#7-操作进程的工具" class="headerlink" title="7.操作进程的工具"></a>7.操作进程的工具</h2><h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h2>]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>ECF</tag>
      </tags>
  </entry>
</search>
